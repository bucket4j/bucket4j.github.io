<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<title>Bucket4j 7.0.0-beta-2020-04-18 Reference</title>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5275939145150040"
            crossorigin="anonymous"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Uncomment @import statement below to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock pre.nowrap,.literalblock pre.nowrap pre,.listingblock pre.nowrap,.listingblock pre.nowrap pre{white-space:pre;word-wrap:normal}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #dddddf}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt,.quoteblock .quoteblock{margin:0 0 1.25em;padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd){background:#f8f8f7}
table.stripes-none tr,table.stripes-odd tr:nth-of-type(even){background:none}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Bucket4j 7.0.0 Reference</h1>
<div class="details">
<span id="revnumber">version 7.0.0,</span>
<span id="revdate">2021-11-29 09</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#about-bucket4j">1. About Bucket4j</a>
<ul class="sectlevel2">
<li><a href="#what-is-bucket4j">1.1. What is Bucket4j</a></li>
<li><a href="#bucket4j-basic-features">1.2. Bucket4j basic features</a></li>
<li><a href="#bucket4j-distributed-features">1.3. Bucket4j distributed features</a></li>
</ul>
</li>
<li><a href="#basic-functionality">2. Basic functionality</a>
<ul class="sectlevel2">
<li><a href="#quick-start-examples">2.1. Quick start examples</a>
<ul class="sectlevel3">
<li><a href="#how-to-dependency-to-bucket4j">2.1.1. How to dependency to Bucket4j</a></li>
<li><a href="#create-your-first-bucket-limiting-the-rate-of-heavy-work">2.1.2. Create your first Bucket, limiting the rate of heavy work</a></li>
<li><a href="#using-bucket-as-scheduler">2.1.3. Using bucket as scheduler</a></li>
<li><a href="#limiting-the-rate-of-access-to-rest-api">2.1.4. Limiting the rate of access to REST API</a></li>
<li><a href="#example-of-multiple-bandwidth">2.1.5. Example of multiple bandwidth</a></li>
<li><a href="#specifying-initial-amount-of-tokens">2.1.6. Specifying initial amount of tokens</a></li>
<li><a href="#turning-off-the-refill-greediness">2.1.7. Turning-off the refill greediness</a></li>
<li><a href="#returning-tokens-back-to-bucket">2.1.8. Returning tokens back to bucket</a></li>
<li><a href="#customizing-time-measurement-choosing-nanotime-time-resolution">2.1.9. Customizing time measurement - choosing nanotime time resolution</a></li>
<li><a href="#customizing-time-measurement-specify-custom-time-measurement-strategy">2.1.10. Customizing time measurement -  Specify custom time measurement strategy</a></li>
</ul>
</li>
<li><a href="#concepts">2.2. Concepts</a>
<ul class="sectlevel3">
<li><a href="#bucket">2.2.1. Bucket</a></li>
<li><a href="#bucket-bonfiguration">2.2.2. BucketConfiguration</a></li>
<li><a href="#bandwidth">2.2.3. Limitation/Bandwidth</a></li>
<li><a href="#refill">2.2.4. Refill</a></li>
<li><a href="#bucket-state">2.2.5. BucketState</a></li>
<li><a href="#local-bucket-builder">2.2.6. BucketBuilder</a></li>
</ul>
</li>
<li><a href="#technical-limitations">2.3. Technical limitations</a>
<ul class="sectlevel3">
<li><a href="#maximum-refill-rate">2.3.1. Maximum refill rate</a></li>
<li><a href="#limitation-for-refill-period">2.3.2. Limitation for refill period</a></li>
</ul>
</li>
<li><a href="#basic-api-reference">2.4. Basic API Reference</a>
<ul class="sectlevel3">
<li><a href="#io-github-bucket4j-bucket">2.4.1. io.github.bucket4j.Bucket</a>
<ul class="sectlevel4">
<li><a href="#tryconsume">tryConsume</a></li>
<li><a href="#consumeignoringratelimits">consumeIgnoringRateLimits</a></li>
<li><a href="#tryconsumeandreturnremaining">tryConsumeAndReturnRemaining</a></li>
<li><a href="#estimateabilitytoconsume">estimateAbilityToConsume</a></li>
<li><a href="#tryconsumeasmuchaspossible">tryConsumeAsMuchAsPossible</a></li>
<li><a href="#addtokens">addTokens</a></li>
<li><a href="#forceaddtokens">forceAddTokens</a></li>
<li><a href="#getavailabletokens">getAvailableTokens</a></li>
<li><a href="#builder">builder</a></li>
<li><a href="#replaceconfiguration">replaceConfiguration</a></li>
<li><a href="#asblocking">asBlocking</a>
<ul class="sectlevel5">
<li><a href="#asscheduler">asScheduler</a></li>
</ul>
</li>
<li><a href="#asverbose">asVerbose</a></li>
<li><a href="#tolistenable">toListenable</a></li>
</ul>
</li>
<li><a href="#blocking-bucket">2.4.2. io.github.bucket4j.BlockingBucket</a>
<ul class="sectlevel4">
<li><a href="#tryconsume-2">tryConsume</a></li>
<li><a href="#tryconsumeuninterruptibly">tryConsumeUninterruptibly</a></li>
<li><a href="#consume">consume</a></li>
<li><a href="#consumeuninterruptibly">consumeUninterruptibly</a></li>
</ul>
</li>
<li><a href="#scheduling-bucket">2.4.3. io.github.bucket4j.SchedulingBucket</a>
<ul class="sectlevel4">
<li><a href="#tryconsume-3">tryConsume</a></li>
<li><a href="#consume-2">consume</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#generic-production-checklist">2.5. Generic production checklist</a>
<ul class="sectlevel3">
<li><a href="#be-wary-of-long-periods">2.5.1. Be wary of long periods</a></li>
<li><a href="#short-timed-bursts">2.5.2. Be wary of short-timed bursts</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#distributed-facilities">3. Distributed facilities</a>
<ul class="sectlevel2">
<li><a href="#jcache-integration">3.1. JCache integration</a>
<ul class="sectlevel3">
<li><a href="#example-1-limiting-access-to-http-server-by-ip-address">3.1.1. Example 1 - limiting access to HTTP server by IP address</a></li>
<li><a href="#example-2-limiting-access-to-service-by-contract-agreements">3.1.2. Example 2 - limiting access to service by contract agreements</a></li>
<li><a href="#example-3-working-with-jcache-without-proxymanager-abstraction">3.1.3. Example 3 - working with JCache without ProxyManager abstraction</a></li>
<li><a href="#runnable-examples-of-jcache-integration">3.1.4. Runnable examples of JCache integration</a></li>
<li><a href="#why-jcache-specification-is-not-enough-and-since-3-0-were-introduced-the-dedicated-modules-for-infinispan-hazelcast-and-ignite">3.1.5. Why JCache specification is not enough and since 3.0 were introduced the dedicated modules for Infinispan, Hazelcast and Ignite?</a></li>
<li><a href="#verification-of-compatibility-with-particular-jcache-provider-is-your-responsibility">3.1.6. Verification of compatibility with particular JCache provider is your responsibility</a></li>
</ul>
</li>
<li><a href="#hazelcast-integration">3.2. Hazelcast integration</a>
<ul class="sectlevel3">
<li><a href="#dependencies">3.2.1. Dependencies</a></li>
<li><a href="#general-compatibility-matrix-principles">3.2.2. General compatibility matrix principles:</a></li>
<li><a href="#example-of-bucket-instantiation">3.2.3. Example of Bucket instantiation</a></li>
<li><a href="#example-of-proxymanager-instantiation">3.2.4. Example of ProxyManager instantiation</a></li>
<li><a href="#configuring-custom-serialization-for-bucket4j-library-classes">3.2.5. Configuring Custom Serialization for Bucket4j library classes</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#known-issues-related-with-docker-andor-springboot">4. Known issues related with Docker and(or) SpringBoot</a>
<ul class="sectlevel2">
<li><a href="#apache-ignite-integration">4.1. Apache Ignite integration</a>
<ul class="sectlevel3">
<li><a href="#dependencies-2">4.1.1. Dependencies</a></li>
<li><a href="#example-of-bucket-instantiation-2">4.1.2. Example of Bucket instantiation</a></li>
<li><a href="#example-of-proxymanager-instantiation-2">4.1.3. Example of ProxyManager instantiation</a></li>
<li><a href="#example-of-bucket-instantiation-via-thin-client">4.1.4. Example of Bucket instantiation via Thin Client</a></li>
<li><a href="#example-of-proxymanager-instantiation-via-thin-client">4.1.5. Example of ProxyManager instantiation via Thin Client</a></li>
</ul>
</li>
<li><a href="#infinispan-integration">4.2. Infinispan integration</a>
<ul class="sectlevel3">
<li><a href="#dependencies-3">4.2.1. Dependencies</a></li>
<li><a href="#general-compatibility-matrix-principles-2">4.2.2. General compatibility matrix principles::</a></li>
<li><a href="#special-notes-for-infinispan-10-0">4.2.3. Special notes for Infinispan 10.0+</a></li>
<li><a href="#example-of-bucket-instantiation-3">4.2.4. Example of Bucket instantiation</a></li>
<li><a href="#example-of-proxymanager-instantiation-3">4.2.5. Example of ProxyManager instantiation</a></li>
</ul>
</li>
<li><a href="#oracle-coherence-integration">4.3. Oracle Coherence integration</a>
<ul class="sectlevel3">
<li><a href="#dependencies-4">4.3.1. Dependencies</a></li>
<li><a href="#example-of-bucket-instantiation-4">4.3.2. Example of Bucket instantiation</a></li>
<li><a href="#example-of-proxymanager-instantiation-4">4.3.3. Example of ProxyManager instantiation</a></li>
<li><a href="#configuring-pof-serialization-for-bucket4j-library-classes">4.3.4. Configuring POF serialization for Bucket4j library classes</a></li>
</ul>
</li>
<li><a href="#asynchronous-api">4.4. Asynchronous API</a>
<ul class="sectlevel3">
<li><a href="#example-limiting-the-rate-of-access-to-asynchronous-servlet">4.4.1. Example - limiting the rate of access to asynchronous servlet</a></li>
</ul>
</li>
<li><a href="#production-checklist-especially-in-the-context-of-distributed-systems">4.5. Production checklist especially in the context of distributed systems</a></li>
</ul>
</li>
<li><a href="#advanced-features">5. Advanced features</a>
<ul class="sectlevel2">
<li><a href="#listener">5.1. Listening for bucket events</a>
<ul class="sectlevel3">
<li><a href="#what-can-be-listened">5.1.1. What can be listened</a></li>
<li><a href="#listener-api-corner-cases">5.1.2. Listener API - corner cases</a></li>
<li><a href="#how-to-attach-listener-to-bucket">5.1.3. How to attach listener to bucket?</a></li>
<li><a href="#example-of-integration-with-dropwizard-metrics-core">5.1.4. Example of integration with Dropwizard metrics-core</a></li>
</ul>
</li>
<li><a href="#verbose-api">5.2. Verbose API</a>
<ul class="sectlevel3">
<li><a href="#verbose-api-entry-points">5.2.1. Verbose API entry-points</a></li>
<li><a href="#principles-of-result-decoration">5.2.2. Principles of result decoration</a></li>
<li><a href="#example-of-verbose-api-usage">5.2.3. Example of Verbose API usage</a></li>
</ul>
</li>
<li><a href="#configuration-replacement">5.3. On-the-fly configuration replacement</a>
<ul class="sectlevel3">
<li><a href="#why-configuration-replacement-is-not-trivial">5.3.1. Why configuration replacement is not trivial?</a></li>
<li><a href="#taking-control-over-replacement-process-via-bandwidth-identifiers">5.3.2. Taking control over replacement process via bandwidth identifiers</a></li>
<li><a href="#tokensinheritancestrategy-explanation">5.3.3. TokensInheritanceStrategy explanation</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="about-bucket4j"><a class="anchor" href="#about-bucket4j"></a>1. About Bucket4j</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="what-is-bucket4j"><a class="anchor" href="#what-is-bucket4j"></a>1.1. What is Bucket4j</h3>
<div class="paragraph">
<p>Bucket4j is Java rate-limiting library is mainly based on token-bucket algorithm, which are by de-facto standard for rate limiting in the IT industry.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="title">Bucket4j is more than direct implementation of token-bucket</div>
Its math model provides several useful extensions that are not mentioned in the classic token-bucket interpretations, such as multiple limits per bucket or overdraft. These math extensions will be detailed described later.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can read more about token bucket by following links:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Token_bucket">Token bucket</a> - wikipedia page describes the token-bucket algorithm in classical form.</p>
</li>
<li>
<p><a href="https://vbukhtoyarov-java.blogspot.com/2021/11/non-formal-overview-of-token-bucket.html">Non-formal overview of token-bucket algorithm</a> - the brief overview of token-bucket algorithm.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="bucket4j-basic-features"><a class="anchor" href="#bucket4j-basic-features"></a>1.2. Bucket4j basic features</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Absolutely non-compromise precision</strong> - Bucket4j does not operate with floats or doubles, all calculation are performed in the integer arithmetic, this feature protects end users from calculation errors involved by rounding.</p>
</li>
<li>
<p><strong>Effective implementation in terms of concurrency</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Bucket4j is good scalable for multi-threading case it by defaults uses lock-free implementation.</p>
</li>
<li>
<p>In same time, library provides different concurrency strategies that can be chosen when default lock-free strategy is not desired.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Effective API in terms of garbage collector footprint</strong>: Bucket4j API tries to use primitive types as much as it is possible in order to avoid boxing and other types of floating garbage.</p>
</li>
<li>
<p><strong>Pluggable listener API</strong> that allows to implement monitoring and logging.</p>
</li>
<li>
<p><strong>Rich diagnostic API</strong> that allows to investigate internal state.</p>
</li>
<li>
<p><strong>Rich configuration management</strong> - configuration of the bucket can be changed on fly</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="bucket4j-distributed-features"><a class="anchor" href="#bucket4j-distributed-features"></a>1.3. Bucket4j distributed features</h3>
<div class="paragraph">
<p>In additional to basic features described above, <code>Bucket4j</code> provides ability to implement rate-limiting in cluster of JVMs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Bucket4j out of the box supports any GRID solution which compatible with JCache API (JSR 107) specification.</p>
</li>
<li>
<p>Bucket4j provides the framework that allows to quickly build integration with your own persistent technology like RDMS or a key-value storage.</p>
</li>
<li>
<p>For clustered usage scenarios Bucket4j supports asynchronous API that extremely matters when going to distribute world, because asynchronous API allows avoiding blocking your application threads each time when you need to execute Network request.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="basic-functionality"><a class="anchor" href="#basic-functionality"></a>2. Basic functionality</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="quick-start-examples"><a class="anchor" href="#quick-start-examples"></a>2.1. Quick start examples</h3>
<div class="sect3">
<h4 id="how-to-dependency-to-bucket4j"><a class="anchor" href="#how-to-dependency-to-bucket4j"></a>2.1.1. How to dependency to Bucket4j</h4>
<div class="paragraph">
<p>The Bucket4j is distributed through <a href="https://mvnrepository.com/artifact/com.github.vladimir-bukhtoyarov/bucket4j-core">Maven Central</a>.
You need to add dependency to your project as described bellow in order to be able to compile and run examples</p>
</div>
<div class="listingblock">
<div class="title">Maven dependency</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.github.vladimir-bukhtoyarov&lt;/groupId&gt;
    &lt;artifactId&gt;bucket4j-core&lt;/artifactId&gt;
    &lt;version&gt;7.0.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle dependency</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">implementation 'com.github.vladimir-bukhtoyarov:bucket4j-core:7.0.0'</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="create-your-first-bucket-limiting-the-rate-of-heavy-work"><a class="anchor" href="#create-your-first-bucket-limiting-the-rate-of-heavy-work"></a>2.1.2. Create your first Bucket, limiting the rate of heavy work</h4>
<div class="paragraph">
<p>Imagine that you have a thread-pool executor and you want to know what your threads are doing in the moment when thread-pool throws RejectedExecutionException.
Printing stacktraces of all threads in the JVM will be the best way to know where are all threads have stuck and why thread-pool is overflown.
But acquiring stacktraces is very cost operation by itself, and you want to do it not often than 1 time per 10 minutes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// define the limit 1 time per 10 minute
Bandwidth limit = Bandwidth.simple(1, Duration.ofMinutes(10));
// construct the bucket
Bucket bucket = Bucket4j.builder().addLimit(limit).build();

...

try {
   executor.execute(anyRunnable);
} catch (RejectedExecutionException e) {
    // print stacktraces only if limit is not exceeded
    if (bucket.tryConsume(1)) {
        ThreadInfo[] stackTraces = ManagementFactory.getThreadMXBean().dumpAllThreads(true, true);
        StacktraceUtils.print(stackTraces);
    }
    throw e;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-bucket-as-scheduler"><a class="anchor" href="#using-bucket-as-scheduler"></a>2.1.3. Using bucket as scheduler</h4>
<div class="paragraph">
<p>Suppose you need to have the fresh exchange rate between dollars and euros.
To get the rate you continuously poll the third-party provider,
and by contract with provider you should poll not often than 100 times per 1 minute, else provider will block your ip:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// define the limit 100 times per 1 minute
Bandwidth limit = Bandwidth.simple(100, Duration.ofMinutes(1));
// construct the bucket
Bucket bucket = Bucket4j.builder().addLimit(limit).build();

...
volatile double exchangeRate;
...

// do polling in infinite loop
while (true) {
  // Consume a token from the token bucket.
  // If a token is not available this method will block until the refill adds one to the bucket.
  bucket.asScheduler().consume(1);

  exchangeRate = pollExchangeRate();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="limiting-the-rate-of-access-to-rest-api"><a class="anchor" href="#limiting-the-rate-of-access-to-rest-api"></a>2.1.4. Limiting the rate of access to REST API</h4>
<div class="paragraph">
<p>Imagine that you develop yet another social network and you want to provide REST API for third-party developers.
To protect your system from overloading you want to introduce following limitation:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>The bucket size is 50 calls (which cannot be exceeded at any given time), with a "refill rate" of 10 calls per second that continually increases tokens in the bucket.
In other words. if client app averages 10 calls per second, it will never be throttled,
and moreover client have overdraft equals to 50 calls which can be used if average is little bit higher that 10 call/sec on short time period.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Constructing the bucket to satisfy the requirements above is little bit more complicated that for previous examples,
because we have deal with overdraft, but it is not rocket science:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.github.bucket4j.Bucket4j;

public class ThrottlingFilter implements javax.servlet.Filter {

    private Bucket createNewBucket() {
         long overdraft = 50;
         Refill refill = Refill.greedy(10, Duration.ofSeconds(1));
         Bandwidth limit = Bandwidth.classic(overdraft, refill);
         return Bucket4j.builder().addLimit(limit).build();
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest httpRequest = (HttpServletRequest) servletRequest;
        HttpSession session = httpRequest.getSession(true);

        String appKey = SecurityUtils.getThirdPartyAppKey();
        Bucket bucket = (Bucket) session.getAttribute("throttler-" + appKey);
        if (bucket == null) {
            bucket = createNewBucket();
            session.setAttribute("throttler-" + appKey, bucket);
        }

        // tryConsume returns false immediately if no tokens available with the bucket
        if (bucket.tryConsume(1)) {
            // the limit is not exceeded
            filterChain.doFilter(servletRequest, servletResponse);
        } else {
            // limit is exceeded
            HttpServletResponse httpResponse = (HttpServletResponse) servletResponse;
            httpResponse.setContentType("text/plain");
            httpResponse.setStatus(429);
            httpResponse.getWriter().append("Too many requests");
        }
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want provide more information to end user about the state of bucket, then last fragment of code above can be rewritten in following way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HttpServletResponse httpResponse = (HttpServletResponse) servletResponse;
        ConsumptionProbe probe = bucket.tryConsumeAndReturnRemaining(1);
        if (probe.isConsumed()) {
            // the limit is not exceeded
            httpResponse.setHeader("X-Rate-Limit-Remaining", "" + probe.getRemainingTokens());
            filterChain.doFilter(servletRequest, servletResponse);
        } else {
            // limit is exceeded
            HttpServletResponse httpResponse = (HttpServletResponse) servletResponse;
            httpResponse.setStatus(429);
            httpResponse.setHeader("X-Rate-Limit-Retry-After-Seconds", "" + TimeUnit.NANOSECONDS.toSeconds(probe.getNanosToWaitForRefill()));
            httpResponse.setContentType("text/plain");
            httpResponse.getWriter().append("Too many requests");
        }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-of-multiple-bandwidth"><a class="anchor" href="#example-of-multiple-bandwidth"></a>2.1.5. Example of multiple bandwidth</h4>
<div class="paragraph">
<p>Imagine that you are developing load testing tool, in order to be ensure that testable system is able to dispatch 1000 requests per 1 minute.
But you do not want to randomly kill the testable system by generation all 1000 events in one second instead of 1 minute.
To solve problem you can construct following bucket:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">static final long MAX_WAIT_NANOS = TimeUnit.HOURS.toNanos(1);
// ...

Bucket bucket = Bucket4j.builder()
       // allows 1000 tokens per 1 minute
       .addLimit(Bandwidth.simple(1000, Duration.ofMinutes(1)))
       // but not often then 50 tokens per 1 second
       .addLimit(Bandwidth.simple(50, Duration.ofSeconds(1)))
       .build();

// ...
while (true) {
  // Consume a token from the token bucket.  If a token is not available this method will block until the refill adds one to the bucket.
  if (bucket.tryConsume(1, MAX_WAIT_NANOS, BlockingStrategy.PARKING)) {
       workloadExecutor.execute(new LoadTask());
  };
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="specifying-initial-amount-of-tokens"><a class="anchor" href="#specifying-initial-amount-of-tokens"></a>2.1.6. Specifying initial amount of tokens</h4>
<div class="paragraph">
<p>By default initial size of bucket equals to capacity.
But sometimes, you may want to have lesser initial size, for example for case of cold start in order to prevent denial of service:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">int initialTokens = 42;
Bandwidth limit = Bandwidth
    .simple(1000, Duration.ofHours(1))
    .withInitialTokens(initialTokens);
Bucket bucket = Bucket4j.builder()
    .addLimit(limit)
    .build();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="turning-off-the-refill-greediness"><a class="anchor" href="#turning-off-the-refill-greediness"></a>2.1.7. Turning-off the refill greediness</h4>
<div class="paragraph">
<p>When bandwidth created via <code>Bandwidth#simple</code> method  it does refill in greedy manner, because bandwidth tries to add the tokens to bucket as soon as possible.
For example bandwidth with refill "10 tokens per 1 second" will add 1 token per each 100 millisecond,
in other words refill will not wait 1 second to regenerate whole bunch of 10 tokens.</p>
</div>
<div class="paragraph">
<p>If greediness is undesired then you should explicitly choose non-greedy refill.
For example the bandwidth bellow will refill 10 tokens per 1 second instead of 1 token per 100 milliseconds:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// When refill created via "intervally" factory method then greediness is turned-off.
Refill refill = Refill.intervally(10, Duration.ofSeconds(1));
Bandwidth bandwidth = Bandwidth.classic(600, refill);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also it is possible to specify the time when first refill should happen.
This option can be used to configure clear interval boundary i.e. start of second, minute, hour, day.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">   // imagine that wall clock is 16:20, and we need to schedule the first refill to 17:00
   Instant firstRefillTime = ZonedDateTime.now()
             .truncatedTo(ChronoUnit.HOURS)
             .plus(1, ChronoUnit.HOURS)
             .toInstant();

   // see detailed explanation for useAdaptiveInitialTokens in the javadocs for 'intervallyAligned' method
   boolean useAdaptiveInitialTokens = false;

   Bandwidth.classic(400, Refill.intervallyAligned(400, Duration.ofHours(1), firstRefillTime, useAdaptiveInitialTokens));</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="returning-tokens-back-to-bucket"><a class="anchor" href="#returning-tokens-back-to-bucket"></a>2.1.8. Returning tokens back to bucket</h4>
<div class="paragraph">
<p>The <a href="https://en.wikipedia.org/wiki/Compensating_transaction">compensating transaction</a> is one of obvious use case when you want to return tokens back to bucket:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Bucket wallet;
...
if (wallet.tryConsume(50)) { // get 50 cents from wallet
    try {
        buyCocaCola();
    } catch(NoCocaColaException e) {
        // return money to wallet
        wallet.addTokens(50);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="customizing-time-measurement-choosing-nanotime-time-resolution"><a class="anchor" href="#customizing-time-measurement-choosing-nanotime-time-resolution"></a>2.1.9. Customizing time measurement - choosing nanotime time resolution</h4>
<div class="paragraph">
<p>By default Bucket4j uses millisecond time resolution, it is preferred time measurement strategy.
But rarely(for example benchmarking) you wish the nanosecond precision:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Bucket4j.builder().withNanosecondPrecision()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Be very careful to choose this time measurement strategy, because <code>System.nanoTime()</code> produces inaccurate results,
use this strategy only if period of bandwidth is too small that millisecond resolution will be undesired.</p>
</div>
</div>
<div class="sect3">
<h4 id="customizing-time-measurement-specify-custom-time-measurement-strategy"><a class="anchor" href="#customizing-time-measurement-specify-custom-time-measurement-strategy"></a>2.1.10. Customizing time measurement -  Specify custom time measurement strategy</h4>
<div class="paragraph">
<p>You can specify your custom time meter, if existing miliseconds or nanotime time meters is not enough for your purposes.
Imagine that you have a clock, which synchronizes its time with other machines in current cluster,
if you want to use time provided by this clock instead of time provided by JVM then you can write something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ClusteredTimeMeter implements TimeMeter {

    @Override
    public long currentTimeNanos() {
        return ClusteredClock.currentTimeMillis() * 1_000_000;
    }

}

Bandwidth limit = Bandwidth.simple(100, Duration.ofMinutes(1));
Bucket bucket = Bucket4j.builder()
    .withCustomTimePrecision(new ClusteredTimeMeter())
    .addLimit(limit)
    .build();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="concepts"><a class="anchor" href="#concepts"></a>2.2. Concepts</h3>
<div class="sect3">
<h4 id="bucket"><a class="anchor" href="#bucket"></a>2.2.1. Bucket</h4>
<div class="paragraph">
<p><code>Bucket</code> is rate-limiter that is implemented on the top of ideas of well-known <a href="https://en.wikipedia.org/wiki/Token_bucket">Token Bucket algorithm</a>.
In the Bucket4j library code the <code>Bucket</code> is represented by interface <a href="https://github.com/vladimir-bukhtoyarov/bucket4j/blob/7.0/bucket4j-core/src/main/java/io/github/bucket4j/Bucket.java">io.github.bucket4j.Bucket</a>.</p>
</div>
<div class="ulist">
<div class="title">Bucket aggregates following parts:</div>
<ul>
<li>
<p><a href="#bucket-bonfiguration">BucketConfiguration</a> specifies an immutable collection of limitation rules that is used by bucket during its work.</p>
</li>
<li>
<p><a href="#bucket-state">BucketState</a> the place where bucket stores mutable state like amount of current available tokens.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Bucket can be constructed via special builder API <a href="#local-bucket-builder">BucketBuilder</a> that is available by factory method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Bucket bucket = Bucket.builder()
   .addLimit(...)
   .build();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bucket-bonfiguration"><a class="anchor" href="#bucket-bonfiguration"></a>2.2.2. BucketConfiguration</h4>
<div class="paragraph">
<p><code>BucketConfiguration</code> can be described as collection of <a href="#bandwidth">limits</a> that are used by <a href="#bucket">Bucket</a> during its job. Configuration
In the Bucket4j library code the <code>BucketConfiguration</code> is represented by class <a href="https://github.com/vladimir-bukhtoyarov/bucket4j/blob/7.0/bucket4j-core/src/main/java/io/github/bucket4j/BucketConfiguration.java">io.github.bucket4j.BucketConfiguration</a>. Configuration is immutable, there is no way to add or remove a limit to already created configuration. However, you can replace configuration of bucket via creating new configuration instance and calling <code>bucket.replaceConfiguration(newConfiguration)</code>.</p>
</div>
<div class="paragraph">
<p>Usually you should not create BucketConfiguration directly(excepting the case with configuration replacement) because <a href="#local-bucket-builder">BucketBuilder</a> does for you behind the scene, for rare cases when you need to create configuration directly you have to use <code>ConfigurationBuilder</code> that is available by factory method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">BucketConfiguration configuration = BucketConfiguration.builder()
    .addLimit(...)
    .build()</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Mostly users configure single limit per configuration, but it is strongly recommended analyzing whether <a href="#short-timed-bursts">short-timed bursts problem</a>
 can affect your application and if so then thinking about to adding more limits.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="bandwidth"><a class="anchor" href="#bandwidth"></a>2.2.3. Limitation/Bandwidth</h4>
<div class="paragraph">
<p>Limitations that are used by bucket can be denoted in terms of bandwidths. Bandwidth is denoted by following terms:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Capacity</dt>
<dd>
<p>Capacity is the term that directly inherited from classic interpretation of token-bucket algorithm, this specifies how many tokens your bucket has.</p>
</dd>
<dt class="hdlist1">Refill</dt>
<dd>
<p><a href="#refill">Refill</a> specifies how fast tokens can be refilled after it were consumed from bucket.</p>
</dd>
<dt class="hdlist1">Initial tokens</dt>
<dd>
<p>Bucket4j extend token-bucket algorithm by allowing to specify initial amount of tokens for each bandwidth. By default, initial amount of tokens equals to capacity, and can be changed by <code>withInitialTokens</code> method:<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Bandwidth bandwidth = Bandwidth.simple(42, Duration.ofMinutes(1))
                          .withInitialTokens(13);</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">ID</dt>
<dd>
<p>Identifier is the optional attribute that is null by default. You may prefer to assign identifiers for bandwidths if you use on the fly configuration replacement and your buckets have more than one bandwidth per bucket, otherwise it is better to avoid using identifiers in order to preserve memory.
Identifier for a bandwidth can be specified by <code>withId</code> method:<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">BucketConfiguration configuration = BucketConfiguration.builder()
        .addLimit(Bandwidth.simple(1000, Duration.ofMinutes(1)).withId("business-limit"))
        .addLimit(Bandwidth.simple(100, Duration.ofSeconds(1)).withId("burst-protection"))
        .build();</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Identifiers are critical for on the fly configuration replacement functionality because during replacement it needs to make decision about how correctly propagate information about already consumed tokens from state before config replacement to state after replacement. This is not trivial task especially when amount of limits is changing.
</td>
</tr>
</table>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="refill"><a class="anchor" href="#refill"></a>2.2.4. Refill</h4>
<div class="paragraph">
<p>Specifies the speed of tokens regeneration.</p>
</div>
<div class="dlist">
<div class="title">There are tree types of refill:</div>
<dl>
<dt class="hdlist1">Greedy</dt>
<dd>
<p>This type of refill regenerates tokens in greedy manner, it tries to add the tokens to bucket as soon as possible. For example refill "10 tokens per 1 second" adds 1 token per each 100 millisecond, in other words refill will not wait 1 second to regenerate whole bunch of 10 tokens. The three refills bellow do refill of tokens with same speed:<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Refill.greedy(600, Duration.ofMinutes(1));
Refill.greedy(10, Duration.ofSeconds(1));
Refill.greedy(1, Duration.ofMillis(100));</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Greedy</code> is default type of refill that is used when you create <code>simple</code> bandwidth<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// the two lines of code bellow are fully equivalent
Bandwidth.simple(100, Duration.ofMinutes(1))
Bandwidth.classic(100, Refill.greedy(100, Duration.ofMinutes(1)))</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">Intervally</dt>
<dd>
<p>This type of refill regenerates tokens in intervally manner. "Intervally" in opposite to "greedy"  will wait until whole period will be elapsed before regenerate the whole amount of tokens.<br></p>
<div class="listingblock">
<div class="title">Example:<br></div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// generates 100 tokens each minute
Refill.greedy(100, Duration.ofMinutes(1));</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">IntervallyAligned</dt>
<dd>
<p>This type of refill regenerates that does refill of tokens in intervally manner. Intervally" in opposite to "greedy"  will wait until whole period will be elapsed before regenerate the whole amount of tokens. In additional to <strong>Intervally</strong> it is possible to specify the time when first refill should happen.  This type can be used to configure clear interval boundary i.e. start of second, minute, hour, day. To get more details reed javadocs for <code>Refill#intervallyAligned</code> method.<br></p>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// imagine that wall clock is 16:20, the first refill will happen at 17:00
// first refill will happen in the beginning of next hour
Instant firstRefillTime = ZonedDateTime.now()
  .truncatedTo(ChronoUnit.HOURS)
  .plus(1, ChronoUnit.HOURS)
  .toInstant();

Bandwidth.classic(400, Refill.intervallyAligned(400, Duration.ofHours(1), firstRefillTime, true));</code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="bucket-state"><a class="anchor" href="#bucket-state"></a>2.2.5. BucketState</h4>
<div class="paragraph">
<p>BucketState is the place where bucket stores own mutable state like:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Amount of current available tokens.</p>
</li>
<li>
<p>Timestamp when the last refill was happen.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>BucketState</code> is represented by interface <a href="https://github.com/vladimir-bukhtoyarov/bucket4j/blob/7.0/bucket4j-core/src/main/java/io/github/bucket4j/Bucket.java">io.github.bucket4j.BucketState</a>. Usually you never interact with this interface, excepting the cases when you want to get access to low-level diagnostic API that is described in</p>
</div>
</div>
<div class="sect3">
<h4 id="local-bucket-builder"><a class="anchor" href="#local-bucket-builder"></a>2.2.6. BucketBuilder</h4>
<div class="paragraph">
<p>It was explicitly decided by library authors to not provide for end users to construct a library entity via direct constructors.</p>
</div>
<div class="ulist">
<div class="title">It were to reason to split built-time and usage-time APIs:</div>
<ul>
<li>
<p>To be able in the future to change internal implementations without breaking backward compatibility.</p>
</li>
<li>
<p>In order to provide <code>Fluent Builder API</code> that in our minds is good modern library design pattern.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>LocalBucketBuilder</code> is a fluent builder that is specialized to construct the local buckets, where local bucket is the bucket that holds  internal state just in memory and does not provide clustering functionality. Bellow an example of LocalBucketBuilder usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Bucket bucket = Bucket.builder()
    .addLimit(Bandwidth.simple())
    .withNanosecondPrecision()
    .withSynchronizationStrategy(SynchronizationStrategy.LOCK_FREE)
    .build()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="technical-limitations"><a class="anchor" href="#technical-limitations"></a>2.3. Technical limitations</h3>
<div class="paragraph">
<p>In order to provide the best precision, Bucket4j uses integer arithmetic as much as possible, so any internal calculation is limited by bound <code>Long.MAX_VALUE</code>. Library introduces several limits that described further, in order to be sure that calculations will never exceed the bound.</p>
</div>
<div class="sect3">
<h4 id="maximum-refill-rate"><a class="anchor" href="#maximum-refill-rate"></a>2.3.1. Maximum refill rate</h4>
<div class="paragraph">
<p>Maximum refill rate is limited by <code>1 token/ 1 nanosecond</code>. Following examples of API usage will raise exceptions</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Bandwidth.simple(2, Duration.ofNanos(1));</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Bandwidth.simple(1001, Duration.ofNanos(1000));</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Bandwidth.simple(1_000_001, Duration.ofMillis(1));</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="limitation-for-refill-period"><a class="anchor" href="#limitation-for-refill-period"></a>2.3.2. Limitation for refill period</h4>
<div class="paragraph">
<p>Bucket4j works with time intervals as the 64-bit number of nanoseconds. So maximum refill period that is possible will be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Duration.ofNanos(Long.MAX_VALUE);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any attempt to specify period longer that limit above will fail with exception. For example the code bellow will failed</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Bandwidth.simple(42, Duration.ofMinutes(153722867280912930));

Exception in thread "main" java.lang.ArithmeticException: long overflow
	at java.lang.Math.multiplyExact(Math.java:892)
	at java.time.Duration.toNanos(Duration.java:1186)
	at io.github.bucket4j.Refill.&lt;init&gt;(Refill.java:48)
	at io.github.bucket4j.Refill.greedy(Refill.java:100)
	at io.github.bucket4j.Bandwidth.simple(Bandwidth.java:102)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="basic-api-reference"><a class="anchor" href="#basic-api-reference"></a>2.4. Basic API Reference</h3>
<div class="sect3">
<h4 id="io-github-bucket4j-bucket"><a class="anchor" href="#io-github-bucket4j-bucket"></a>2.4.1. io.github.bucket4j.Bucket</h4>
<div class="sect4">
<h5 id="tryconsume"><a class="anchor" href="#tryconsume"></a>tryConsume</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
* Tries to consume a specified number of tokens from this bucket.
*
* @param numTokens The number of tokens to consume from the bucket, must be a positive number.
*
* @return {@code true} if the tokens were consumed, {@code false} otherwise.
*/
boolean tryConsume(long numTokens);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="consumeignoringratelimits"><a class="anchor" href="#consumeignoringratelimits"></a>consumeIgnoringRateLimits</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * Consumes {@code tokens} from bucket ignoring all limits.
     * In result of this operation amount of tokens in the bucket could became negative.
     *
     * There are two possible reasons to use this method:
     * &lt;ul&gt;
     * &lt;li&gt;An operation with high priority should be executed independently of rate limits, but it should take effect to subsequent operation with bucket.&lt;/li&gt;
     * &lt;li&gt;You want to apply custom blocking strategy instead of default which applied on {@code asScheduler().consume(tokens)} &lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param tokens amount of tokens that should be consumed from bucket.
     *
     * @return
     * the amount of rate limit violation in nanoseconds calculated in following way:
     * &lt;ul&gt;
     *     &lt;li&gt;&lt;tt&gt;zero&lt;/tt&gt; if rate limit was not violated. For example bucket had 5 tokens before invocation of {@code consumeIgnoringRateLimits(2)},
     *     after invocation there are 3 tokens remain in the bucket, since limits were not violated &lt;tt&gt;zero&lt;/tt&gt; returned as result.&lt;/li&gt;
     *     &lt;li&gt;Positive value which describes the amount of rate limit violation in nanoseconds.
     *     For example bucket with limit 10 tokens per 1 second, currently has the 2 tokens available, last refill happen 100 milliseconds ago, and {@code consumeIgnoringRateLimits(6)} called.
     *     &lt;tt&gt;300_000_000&lt;/tt&gt; will be returned as result and available tokens in the bucket will became &lt;tt&gt;-3&lt;/tt&gt;, and any variation of {@code tryConsume...} will not be successful for 400 milliseconds(time required to refill amount of available tokens until 1).
     *     &lt;/li&gt;
     * &lt;/ul&gt;
     */
    long consumeIgnoringRateLimits(long tokens);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="tryconsumeandreturnremaining"><a class="anchor" href="#tryconsumeandreturnremaining"></a>tryConsumeAndReturnRemaining</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * Tries to consume a specified number of tokens from this bucket.
     *
     * @param numTokens The number of tokens to consume from the bucket, must be a positive number.
     *
     * @return {@link ConsumptionProbe} which describes both result of consumption and tokens remaining in the bucket after consumption.
     */
    ConsumptionProbe tryConsumeAndReturnRemaining(long numTokens);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="estimateabilitytoconsume"><a class="anchor" href="#estimateabilitytoconsume"></a>estimateAbilityToConsume</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * Estimates ability to consume a specified number of tokens.
     *
     * @param numTokens The number of tokens to consume, must be a positive number.
     *
     * @return {@link EstimationProbe} which describes the ability to consume.
     */
    EstimationProbe estimateAbilityToConsume(long numTokens);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="tryconsumeasmuchaspossible"><a class="anchor" href="#tryconsumeasmuchaspossible"></a>tryConsumeAsMuchAsPossible</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * Tries to consume as much tokens from this bucket as available at the moment of invocation.
     *
     * @return number of tokens which has been consumed, or zero if was consumed nothing.
     */
    long tryConsumeAsMuchAsPossible();
    /**
     * Tries to consume as much tokens from bucket as available in the bucket at the moment of invocation,
     * but tokens which should be consumed is limited by {@code limit}.
     *
     * @param limit maximum number of tokens to consume, should be positive.
     *
     * @return number of tokens which has been consumed, or zero if was consumed nothing.
     */
    long tryConsumeAsMuchAsPossible(long limit);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="addtokens"><a class="anchor" href="#addtokens"></a>addTokens</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * Add &lt;tt&gt;tokensToAdd&lt;/tt&gt; to bucket.
     * Resulted count of tokens are calculated by following formula:
     * &lt;pre&gt;newTokens = Math.min(capacity, currentTokens + tokensToAdd)&lt;/pre&gt;
     * in other words resulted number of tokens never exceeds capacity independent of &lt;tt&gt;tokensToAdd&lt;/tt&gt;.
     *
     * &lt;h3&gt;Example of usage&lt;/h3&gt;
     * The "compensating transaction" is one of obvious use case, when any piece of code consumed tokens from bucket, tried to do something and failed, the "addTokens" will be helpful to return tokens back to bucket:
     * &lt;pre&gt;{@code
     *      Bucket wallet;
     *      ...
     *      if(wallet.tryConsume(50)) {// get 50 cents from wallet
     *         try {
     *             buyCocaCola();
     *         } catch(NoCocaColaException e) {
     *             // return money to wallet
     *             wallet.addTokens(50);
     *         }
     *      };
     * }&lt;/pre&gt;
     *
     * @param tokensToAdd number of tokens to add
     */
    void addTokens(long tokensToAdd);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="forceaddtokens"><a class="anchor" href="#forceaddtokens"></a>forceAddTokens</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * Add &lt;tt&gt;tokensToAdd&lt;/tt&gt; to bucket. In opposite to {@link #addTokens(long)} usage of this method can lead to overflow bucket capacity.
     *
     * &lt;h3&gt;Example of usage&lt;/h3&gt;
     * The "compensating transaction" is one of obvious use case, when any piece of code consumed tokens from bucket, tried to do something and failed, the "addTokens" will be helpful to return tokens back to bucket:
     * &lt;pre&gt;{@code
     *      Bucket wallet;
     *      ...
     *      if(wallet.tryConsume(50)) {// get 50 cents from wallet
     *         try {
     *             buyCocaCola();
     *         } catch(NoCocaColaException e) {
     *             // return money to wallet
     *             wallet.addTokens(50);
     *         }
     *      };
     * }&lt;/pre&gt;
     *
     * @param tokensToAdd number of tokens to add
     */
    void forceAddTokens(long tokensToAdd);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="getavailabletokens"><a class="anchor" href="#getavailabletokens"></a>getAvailableTokens</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * Returns amount of available tokens in this bucket.
* &lt;p&gt;
*     Typically you should avoid using of this method for, because available tokens can be changed by concurrent transactions for case of multithreaded/multi-process environment.
*
* @return amount of available tokens
*/
long getAvailableTokens();</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="builder"><a class="anchor" href="#builder"></a>builder</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
* Creates the new builder of in-memory buckets.
*
* @return new instance of {@link LocalBucketBuilder}
*/
static LocalBucketBuilder builder() {
    return new LocalBucketBuilder();
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="replaceconfiguration"><a class="anchor" href="#replaceconfiguration"></a>replaceConfiguration</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * Replaces configuration of this bucket.
     *
     * &lt;p&gt;
     * The first hard problem of configuration replacement is making decision how to propagate available tokens from bucket with previous configuration to bucket with new configuration.
     * If you don't care about previous bucket state then use {@link TokensInheritanceStrategy#RESET}.
     * But it becomes to a tricky problem when we expect that previous consumption(that has not been compensated by refill yet) should take effect to the bucket with new configuration.
     * In this case you need to make a choice between {@link TokensInheritanceStrategy#PROPORTIONALLY} and {@link TokensInheritanceStrategy#AS_IS}, read documentation about both with strong attention.
     *
     * &lt;p&gt; There is another problem when you are choosing {@link TokensInheritanceStrategy#PROPORTIONALLY} and {@link TokensInheritanceStrategy#AS_IS} and bucket has more then one bandwidth.
     * For example how does replaceConfiguration implementation should bind bandwidths to each other in the following example?
     * &lt;pre&gt;
     * &lt;code&gt;
     *     Bucket bucket = Bucket4j.builder()
     *                       .addLimit(Bandwidth.simple(10, Duration.ofSeconds(1)))
     *                       .addLimit(Bandwidth.simple(10000, Duration.ofHours(1)))
     *                       .build();
     *     ...
     *     BucketConfiguration newConfiguration = Bucket4j.configurationBuilder()
     *                                               .addLimit(Bandwidth.simple(5000, Duration.ofHours(1)))
     *                                               .addLimit(Bandwidth.simple(100, Duration.ofSeconds(10)))
     *                                               .build();
     *     bucket.replaceConfiguration(newConfiguration, TokensInheritanceStrategy.AS_IS);
     * &lt;/code&gt;
     * &lt;/pre&gt;
     * It is obviously that simple strategy - copying tokens by bandwidth index will not work well in this case, because of it highly depends from order.
     * Instead of inventing the backward maggic Bucket4j provides to you ability to deap controll of this process by specifying identifiers for bandwidth,
     * so in case of multiple bandwidth configuratoin replacement code can copy available tokens by bandwidth ID. So it is better to rewrite code above as following:
     * &lt;pre&gt;
     * &lt;code&gt;
     * Bucket bucket = Bucket4j.builder()
     *                            .addLimit(Bandwidth.simple(10, Duration.ofSeconds(1)).withId("technical-limit"))
     *                            .addLimit(Bandwidth.simple(10000, Duration.ofHours(1)).withId("business-limit"))
     *                            .build();
     * ...
     * BucketConfiguration newConfiguration = Bucket4j.configurationBuilder()
     *                            .addLimit(Bandwidth.simple(5000, Duration.ofHours(1)).withId("business-limit"))
     *                            .addLimit(Bandwidth.simple(100, Duration.ofSeconds(10)).withId("technical-limit"))
     *                            .build();
     * bucket.replaceConfiguration(newConfiguration, TokensInheritanceStrategy.AS_IS);
     * &lt;/code&gt;
     * &lt;/pre&gt;
     *
     *
     * &lt;p&gt;
 *     There are following rules for bandwidth identifiers:
     * &lt;ul&gt;
     *     &lt;li&gt;
     *          By default bandwidth has &lt;b&gt;null&lt;/b&gt; identifier.
     *     &lt;/li&gt;
     *     &lt;li&gt;
     *         null value of identifier equals to another null value if and only if there is only one bandwidth with null identifier.
     *     &lt;/li&gt;
     *     &lt;li&gt;
     *         If identifier for bandwidth is specified then it must has unique in the bucket. Bucket does not allow to create several bandwidth with same ID.
     *     &lt;/li&gt;
     *     &lt;li&gt;
     *         {@link TokensInheritanceStrategy#RESET} strategy will be applied for tokens migration during config replacement for bandwidth which has no bound bandwidth with same ID in previous configuration,
     *         idependently of strategy that was requested.
     *     &lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param newConfiguration the new configuration
     * @param tokensInheritanceStrategy specifies the rules for inheritance of available tokens
     */
     void replaceConfiguration(BucketConfiguration newConfiguration, TokensInheritanceStrategy tokensInheritanceStrategy);</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="#configuration-replacement">configuration replacement</a> section for more details.</p>
</div>
</div>
<div class="sect4">
<h5 id="asblocking"><a class="anchor" href="#asblocking"></a>asBlocking</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * Returns the blocking API for this bucket, that provides operations which are able to block caller thread in case of lack of tokens.
     *
     * @return the blocking API for this bucket.
     *
     * @see BlockingBucket
     */
    BlockingBucket asBlocking();</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="#blocking-bucket">BlockingBucket</a> section for more details.</p>
</div>
<div class="sect5">
<h6 id="asscheduler"><a class="anchor" href="#asscheduler"></a>asScheduler</h6>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * Returns the scheduling API for this bucket, that provides operations which can delay user operation via {@link java.util.concurrent.ScheduledExecutorService} in case of lack of tokens.
     *
     * @return the scheduling API for this bucket.
     *
     * @see SchedulingBucket
     */
    SchedulingBucket asScheduler();</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="#scheduling-bucket">SchedulingBucket</a> section for more details.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="asverbose"><a class="anchor" href="#asverbose"></a>asVerbose</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * Returns the verbose API for this bucket.
     *
     * @return the verbose API for this bucket.
     */
    VerboseBucket asVerbose();</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="#verbose-api">Verbose API</a> section for more details.</p>
</div>
</div>
<div class="sect4">
<h5 id="tolistenable"><a class="anchor" href="#tolistenable"></a>toListenable</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * Returns new copy of this bucket instance decorated by {@code listener}.
     * The created bucket will share same tokens with source bucket and vice versa.
     *
     * See javadocs for {@link BucketListener} in order to understand semantic of listener.
     *
     * @param listener the listener of bucket events.
     *
     * @return new bucket instance decorated by {@code listener}
     */
    Bucket toListenable(BucketListener listener);</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="#listener">Listening bucket events</a> section for more details.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="blocking-bucket"><a class="anchor" href="#blocking-bucket"></a>2.4.2. io.github.bucket4j.BlockingBucket</h4>
<div class="sect4">
<h5 id="tryconsume-2"><a class="anchor" href="#tryconsume-2"></a>tryConsume</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * Tries to consume a specified number of tokens from the bucket.
     *
     * &lt;p&gt;
     * The algorithm is following:
     * &lt;ul&gt;
     *     &lt;li&gt;If bucket has enough tokens, then tokens consumed and &lt;tt&gt;true&lt;/tt&gt; returned immediately.&lt;/li&gt;
     *     &lt;li&gt;If bucket has no enough tokens,
     *     and required amount of tokens can not be refilled,
     *     even after waiting of &lt;code&gt;maxWaitTimeNanos&lt;/code&gt; nanoseconds,
     *     then consumes nothing and returns &lt;tt&gt;false&lt;/tt&gt; immediately.
     *     &lt;/li&gt;
     *     &lt;li&gt;
     *         If bucket has no enough tokens,
     *         but deficit can be closed in period of time less then &lt;code&gt;maxWaitTimeNanos&lt;/code&gt; nanoseconds,
     *         then tokens consumed(reserved in fair manner) from bucket and current thread blocked for a time required to close deficit,
     *         after unblocking method returns &lt;tt&gt;true&lt;/tt&gt;.
     *
     *         &lt;p&gt;
     *         &lt;strong&gt;Note:&lt;/strong&gt; If InterruptedException happen when thread was blocked
     *         then tokens will be not returned back to bucket,
     *         but you can use {@link Bucket#addTokens(long)} to returned tokens back.
     *     &lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param numTokens The number of tokens to consume from the bucket.
     * @param maxWaitTimeNanos limit of time(in nanoseconds) which thread can wait.
     * @param blockingStrategy specifies the way to block current thread to amount of time required to refill missed number of tokens in the bucket
     *
     * @return true if {@code numTokens} has been consumed or false when {@code numTokens} has not been consumed
     *
     * @throws InterruptedException in case of current thread has been interrupted during the waiting
     */
    boolean tryConsume(long numTokens, long maxWaitTimeNanos, BlockingStrategy blockingStrategy) throws InterruptedException;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * This is just overloaded equivalent of {@link #tryConsume(long, long, BlockingStrategy)}
     *
     * @see #tryConsume(long, long, BlockingStrategy)
     *
     * @param numTokens The number of tokens to consume from the bucket.
     * @param maxWait limit of time which thread can wait.
     * @param blockingStrategy specifies the way to block current thread to amount of time required to refill missed number of tokens in the bucket
     *
     * @return true if {@code numTokens} has been consumed or false when {@code numTokens} has not been consumed
     *
     * @throws InterruptedException in case of current thread has been interrupted during the waiting
     */
    default boolean tryConsume(long numTokens, Duration maxWait, BlockingStrategy blockingStrategy) throws InterruptedException {
        return tryConsume(numTokens, maxWait.toNanos(), blockingStrategy);
    }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * This is just overloaded equivalent of {@link #tryConsume(long, long, BlockingStrategy)}
     *
     * @see #tryConsume(long, long, BlockingStrategy)
     *
     * @param numTokens The number of tokens to consume from the bucket.
     * @param maxWaitTimeNanos limit of time(in nanoseconds) which thread can wait.
     *
     * @return true if {@code numTokens} has been consumed or false when {@code numTokens} has not been consumed
     *
     * @throws InterruptedException in case of current thread has been interrupted during the waiting
     */
    default boolean tryConsume(long numTokens, long maxWaitTimeNanos) throws InterruptedException {
        return tryConsume(numTokens, maxWaitTimeNanos, BlockingStrategy.PARKING);
    }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * This is just overloaded equivalent of {@link #tryConsume(long, long, BlockingStrategy)}
     *
     * @see #tryConsume(long, long, BlockingStrategy)
     *
     * @param numTokens The number of tokens to consume from the bucket.
     * @param maxWait limit of time which thread can wait.
     *
     * @return true if {@code numTokens} has been consumed or false when {@code numTokens} has not been consumed
     *
     * @throws InterruptedException in case of current thread has been interrupted during the waiting
     */
    default boolean tryConsume(long numTokens, Duration maxWait) throws InterruptedException {
        return tryConsume(numTokens, maxWait.toNanos(), BlockingStrategy.PARKING);
    }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="tryconsumeuninterruptibly"><a class="anchor" href="#tryconsumeuninterruptibly"></a>tryConsumeUninterruptibly</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * Has same semantic with {@link #tryConsume(long, long, BlockingStrategy)} but ignores interrupts(just restores interruption flag on exit).
     *
     * @param numTokens The number of tokens to consume from the bucket.
     * @param maxWaitTimeNanos limit of time(in nanoseconds) which thread can wait.
     * @param blockingStrategy specifies the way to block current thread to amount of time required to refill missed number of tokens in the bucket
     *
     * @return true if {@code numTokens} has been consumed or false when {@code numTokens} has not been consumed
     *
     * @see #tryConsume(long, long, BlockingStrategy)
     */
    boolean tryConsumeUninterruptibly(long numTokens, long maxWaitTimeNanos, UninterruptibleBlockingStrategy blockingStrategy);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * This is just overloaded equivalent of {@link #tryConsumeUninterruptibly(long, long, UninterruptibleBlockingStrategy)}
     *
     * @param numTokens The number of tokens to consume from the bucket.
     * @param maxWait limit of time which thread can wait.
     * @param blockingStrategy specifies the way to block current thread to amount of time required to refill missed number of tokens in the bucket
     *
     * @return true if {@code numTokens} has been consumed or false when {@code numTokens} has not been consumed
     *
     * @see #tryConsumeUninterruptibly(long, long, UninterruptibleBlockingStrategy)
     */
    default boolean tryConsumeUninterruptibly(long numTokens, Duration maxWait, UninterruptibleBlockingStrategy blockingStrategy) {
        return tryConsumeUninterruptibly(numTokens, maxWait.toNanos(), blockingStrategy);
    }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * This is just overloaded equivalent of {@link #tryConsumeUninterruptibly(long, long, UninterruptibleBlockingStrategy)}
     *
     * @param numTokens The number of tokens to consume from the bucket.
     * @param maxWaitTimeNanos limit of time(in nanoseconds) which thread can wait.
     *
     * @return true if {@code numTokens} has been consumed or false when {@code numTokens} has not been consumed
     *
     * @see #tryConsumeUninterruptibly(long, long, UninterruptibleBlockingStrategy)
     */
    default boolean tryConsumeUninterruptibly(long numTokens, long maxWaitTimeNanos) {
        return tryConsumeUninterruptibly(numTokens, maxWaitTimeNanos, UninterruptibleBlockingStrategy.PARKING);
    }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * This is just overloaded equivalent of {@link #tryConsumeUninterruptibly(long, long, UninterruptibleBlockingStrategy)}
     *
     * @param numTokens The number of tokens to consume from the bucket.
     * @param maxWait limit of time which thread can wait.
     *
     * @return true if {@code numTokens} has been consumed or false when {@code numTokens} has not been consumed
     *
     * @see #tryConsumeUninterruptibly(long, long, UninterruptibleBlockingStrategy)
     */
    default boolean tryConsumeUninterruptibly(long numTokens, Duration maxWait) {
        return tryConsumeUninterruptibly(numTokens, maxWait.toNanos(), UninterruptibleBlockingStrategy.PARKING);
    }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="consume"><a class="anchor" href="#consume"></a>consume</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * Consumes a specified number of tokens from the bucket.
     *
     * &lt;p&gt;
     * The algorithm is following:
     * &lt;ul&gt;
     *     &lt;li&gt;If bucket has enough tokens, then tokens consumed and method returns immediately.&lt;/li&gt;
     *     &lt;li&gt;
     *         If bucket has no enough tokens, then required amount of tokens will be reserved for future consumption
     *         and current thread will be blocked for a time required to close deficit.
     *     &lt;/li&gt;
     *     &lt;li&gt;
     *         &lt;strong&gt;Note:&lt;/strong&gt; If InterruptedException happen when thread was blocked
     *         then tokens will be not returned back to bucket,
     *         but you can use {@link Bucket#addTokens(long)} to returned tokens back.
     *     &lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param numTokens The number of tokens to consume from the bucket.
     * @param blockingStrategy specifies the way to block current thread to amount of time required to refill missed number of tokens in the bucket
     *
     *
     * @throws InterruptedException in case of current thread has been interrupted during the waiting
     */
    void consume(long numTokens, BlockingStrategy blockingStrategy) throws InterruptedException;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * This is just overloaded equivalent of {@link #consume(long, BlockingStrategy)}
     *
     * @param numTokens The number of tokens to consume from the bucket.
     *
     * @throws InterruptedException in case of current thread has been interrupted during the waiting
     *
     * @see #consume(long, BlockingStrategy)
     */
    default void consume(long numTokens) throws InterruptedException {
        consume(numTokens, BlockingStrategy.PARKING);
    }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="consumeuninterruptibly"><a class="anchor" href="#consumeuninterruptibly"></a>consumeUninterruptibly</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * Has same semantic with {@link #consume(long, BlockingStrategy)} but ignores interrupts(just restores interruption flag on exit).
     *
     * @param numTokens The number of tokens to consume from the bucket.
     * @param blockingStrategy specifies the way to block current thread to amount of time required to refill missed number of tokens in the bucket
     *
     * @see #consume(long, BlockingStrategy)
     */
    void consumeUninterruptibly(long numTokens, UninterruptibleBlockingStrategy blockingStrategy);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * This is just overloaded equivalent of {@link #consumeUninterruptibly(long, UninterruptibleBlockingStrategy)}
     *
     * @param numTokens The number of tokens to consume from the bucket.
     *
     * @see #consumeUninterruptibly(long, UninterruptibleBlockingStrategy)
     */
    default void consumeUninterruptibly(long numTokens) {
        consumeUninterruptibly(numTokens, UninterruptibleBlockingStrategy.PARKING);
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="scheduling-bucket"><a class="anchor" href="#scheduling-bucket"></a>2.4.3. io.github.bucket4j.SchedulingBucket</h4>
<div class="sect4">
<h5 id="tryconsume-3"><a class="anchor" href="#tryconsume-3"></a>tryConsume</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
* Tries to consume the specified number of tokens from the bucket.
*
* &lt;p&gt;
* &lt;strong&gt;The algorithm for all type of buckets is following:&lt;/strong&gt;
* &lt;ul&gt;
*     &lt;li&gt;Implementation issues asynchronous request to back-end behind the bucket(for local bucket it is just a synchronous call) in way which specific for each particular back-end.&lt;/li&gt;
*     &lt;li&gt;Then uncompleted future returned to the caller.&lt;/li&gt;
*     &lt;li&gt;If back-end provides signal(through callback) that asynchronous request failed, then future completed exceptionally.&lt;/li&gt;
*     &lt;li&gt;When back-end provides signal(through callback) that request is done(for local bucket response got immediately), then following post-processing rules will be applied:
*          &lt;ul&gt;
*              &lt;li&gt;
*                  If tokens were consumed then future immediately completed by &lt;tt&gt;true&lt;/tt&gt;.
*              &lt;/li&gt;
*              &lt;li&gt;
*                  If tokens were not consumed because were not enough tokens in the bucket and &lt;tt&gt;maxWaitNanos&lt;/tt&gt; nanoseconds is not enough time to refill deficit,
*                  then future immediately completed by &lt;tt&gt;false&lt;/tt&gt;.
*              &lt;/li&gt;
*              &lt;li&gt;
*                  If tokens were reserved(effectively consumed) then &lt;tt&gt;task&lt;/tt&gt; to delayed completion will be scheduled to the &lt;tt&gt;scheduler&lt;/tt&gt; via {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)},
*                  when delay equals to time required to refill the deficit of tokens. After scheduler executes task the future completed by &lt;tt&gt;true&lt;/tt&gt;.
*              &lt;/li&gt;
*          &lt;/ul&gt;
*     &lt;/li&gt;
* &lt;/ul&gt;
* It is strongly not recommended to do any heavy work in thread which completes the future,
* because typically this will be a back-end thread which handles NIO selectors,
* blocking this thread will take negative performance effect to back-end throughput,
* so you always should resume control flow in another executor via methods like {@link CompletableFuture#thenApplyAsync(Function, Executor)}.
*
* @param numTokens The number of tokens to consume from the bucket.
* @param maxWaitNanos limit of time(in nanoseconds) which thread can wait.
* @param scheduler used to delayed future completion
*/
CompletableFuture&lt;Boolean&gt; tryConsume(long numTokens, long maxWaitNanos, ScheduledExecutorService scheduler);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * This is just overloaded equivalent of {@link #tryConsume(long, long, ScheduledExecutorService)}
     *
     * @param numTokens The number of tokens to consume from the bucket.
     * @param maxWait limit of time which thread can wait.
     * @param scheduler used to delayed future completion
     *
     * @see #tryConsume(long, long, ScheduledExecutorService)
     */
    default CompletableFuture&lt;Boolean&gt; tryConsume(long numTokens, Duration maxWait, ScheduledExecutorService scheduler) {
        return tryConsume(numTokens, maxWait.toNanos(), scheduler);
    }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="consume-2"><a class="anchor" href="#consume-2"></a>consume</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    /**
     * Consumes the specified number of tokens from the bucket.
     *
     * &lt;p&gt;
     * &lt;strong&gt;The algorithm for all type of buckets is following:&lt;/strong&gt;
     * &lt;ul&gt;
     *     &lt;li&gt;Implementation issues asynchronous request to back-end behind the bucket(for local bucket it is just a synchronous call) in way which specific for each particular back-end.&lt;/li&gt;
     *     &lt;li&gt;Then uncompleted future returned to the caller.&lt;/li&gt;
     *     &lt;li&gt;If back-end provides signal(through callback) that asynchronous request failed, then future completed exceptionally.&lt;/li&gt;
     *     &lt;li&gt;When back-end provides signal(through callback) that request is done(for local bucket response got immediately), then following post-processing rules will be applied:
     *          &lt;ul&gt;
     *              &lt;li&gt;
     *                  If tokens were consumed then future immediately completed.
     *              &lt;/li&gt;
     *              &lt;li&gt;
     *                  Else tokens reserved(effectively consumed) and &lt;tt&gt;task&lt;/tt&gt; to delayed completion will be scheduled to the &lt;tt&gt;scheduler&lt;/tt&gt; via {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)},
     *                  when delay equals to time required to refill the deficit of tokens. After scheduler executes task the future completed.
     *              &lt;/li&gt;
     *          &lt;/ul&gt;
     *     &lt;/li&gt;
     * &lt;/ul&gt;
     * It is strongly not recommended to do any heavy work in thread which completes the future,
     * because typically this will be a back-end thread which handles NIO selectors,
     * blocking this thread will take negative performance effect to back-end throughput,
     * so you always should resume control flow in another executor via methods like {@link CompletableFuture#thenApplyAsync(Function, Executor)}.
     *
     * @param numTokens The number of tokens to consume from the bucket.
     * @param scheduler used to delayed future completion
     *
     */
    CompletableFuture&lt;Void&gt; consume(long numTokens, ScheduledExecutorService scheduler);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="generic-production-checklist"><a class="anchor" href="#generic-production-checklist"></a>2.5. Generic production checklist</h3>
<div class="paragraph">
<p>The considerations described bellow are applicable to each solution based on the token-bucket or leaky-bucket algorithm.
You need to understand, agree and configure following points:</p>
</div>
<div class="sect3">
<h4 id="be-wary-of-long-periods"><a class="anchor" href="#be-wary-of-long-periods"></a>2.5.1. Be wary of long periods</h4>
<div class="paragraph">
<p>When you are planning to use any solution based on token-bucket for throttling incoming requests,
you need to pay close attention to the throttling time window.</p>
</div>
<div class="ulist">
<div class="title">Example of a dangerous configuration:</div>
<ul>
<li>
<p>Given a bucket with a limit of 10000 tokens/ per 1 hour per user.</p>
</li>
<li>
<p>A malicious attacker may send 9999 request in very short period, for example within 10 seconds. This would correspond to 100 request per second which could seriously impact your system.</p>
</li>
<li>
<p>A skilled attacker could stop at 9999 request per hour, and repeat every hour, which would make this attack impossible to detect (because the limit would not be reached).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To protect from this kind attacks, you should specify multiple limits like bellow</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Bucket bucket = Bucket4j.jCacheBuilder(RecoveryStrategy.RECONSTRUCT)
    .addLimit(Bandwidth.simple(10000, Duration.ofSeconds(3_600))
    .addLimit(Bandwidth.simple(20, Duration.ofSeconds(1)) // attacker is unable to achieve 1000RPS and crash service in short time
    .build(cache, bucketId);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The number of limits specified per bucket does not impact the performance.</p>
</div>
</div>
<div class="sect3">
<h4 id="short-timed-bursts"><a class="anchor" href="#short-timed-bursts"></a>2.5.2. Be wary of short-timed bursts</h4>
<div class="paragraph">
<p>Token bucket is an efficient algorithm with low and fixed memory footprint, independently of the incoming request-rate(it can be millions per second) the bucket consumes no more then 40 bytes(five longs).
But an efficient memory footprint has its own cost - bandwidth limitation is only satisfied over a long period of time. In other words you cannot avoid short-timed bursts.</p>
</div>
<div class="ulist">
<div class="title">Let us describe an example of local burst:</div>
<ul>
<li>
<p>Given a bucket with a limit of 100 tokens/min. We start with a full bucket, i.e. with 100 tokens.</p>
</li>
<li>
<p>At <code>T1</code> 100 requests are made and thus the bucket becomes empty.</p>
</li>
<li>
<p>At <code>T1+1min</code> the bucket is full again because tokens fully regenerated and we can immediately consume 100 tokens.</p>
</li>
<li>
<p>This means that between  <code>T1</code> and <code>T1+1min</code> we have consumed 200 tokens. Over a long period of time there will be no more than 100 requests per min, but as shown above it is possible to burst at <strong>twice the limit</strong> here at 100 tokens per min.</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">These bursts are inherent to token bucket algorithms and cannot be avoided. If short-timed bursts are unacceptable you then have three options:</div>
<ul>
<li>
<p>Do not use Bucket4j or any other solution implemented on top of token-bucket algorithms, because token-bucket is specially designed for network traffic management devices for which short-living traffic spike is a regular case, trying to avoid spike at all contradicts with the nature of token-bucket.</p>
</li>
<li>
<p>Since the value of burst always equals to capacity, try to reduce the capacity and speed of refill. For example if you have <strong><strong>strong</strong></strong> requirements <code>100tokens/60seconds</code> then configure bucket as <code>capacity=50tokens  refill=50tokens/60seconds</code>. It worth to mention that this way leads to following drawbacks:&#8201;&#8212;&#8201;In one time you are not allowed to consume amount of tokens greater than capacity, according to example above - before capacity reducing you was able to consume 100 tokens in single request, after reducing you are able to consume 50 tokens in one request at max.&#8201;&#8212;&#8201;Reducing the speed of refill leads to underconsumptions on long term periods, it is obvious that with refill <code>50tokens/60seconds</code> you will be able to consume 3050 tokens for 1 hour, instead of 6100(as was prior refill reducing).&#8201;&#8212;&#8201;As a summary of two drawbacks above, we can say that you will pay via <strong>underconsumption</strong> for eliminating the risk of <strong>overconsumption</strong>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="distributed-facilities"><a class="anchor" href="#distributed-facilities"></a>3. Distributed facilities</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="jcache-integration"><a class="anchor" href="#jcache-integration"></a>3.1. JCache integration</h3>
<div class="paragraph">
<p><code>Bucket4j</code> supports any GRID solution which compatible with <a href="https://www.jcp.org/en/jsr/detail?id=107">JCache API (JSR 107)</a> specification.</p>
</div>
<div class="paragraph">
<p><strong>Do not forget to read</strong> [JCache production checklist](production-jcache-checklist.md) <strong>before using the Bucket4j over JCache cluster.</strong></p>
</div>
<div class="paragraph">
<p>To use JCache extension you also need to add following dependency:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.github.vladimir-bukhtoyarov&lt;/groupId&gt;
    &lt;artifactId&gt;bucket4j-jcache&lt;/artifactId&gt;
    &lt;version&gt;7.0.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>JCache expects javax.cache.cache-api to be a provided dependency. Do not forget to add following dependency:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;javax.cache&lt;/groupId&gt;
    &lt;artifactId&gt;cache-api&lt;/artifactId&gt;
    &lt;version&gt;${jcache.version}&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="example-1-limiting-access-to-http-server-by-ip-address"><a class="anchor" href="#example-1-limiting-access-to-http-server-by-ip-address"></a>3.1.1. Example 1 - limiting access to HTTP server by IP address</h4>
<div class="paragraph">
<p>Imagine that you develop any Servlet based WEB application and want to limit access per IP basis.
You want to use same limits for each IP - 30 requests per minute.</p>
</div>
<div class="paragraph">
<p>ServletFilter would be obvious place to check limits:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class IpThrottlingFilter implements javax.servlet.Filter {

    private static final BucketConfiguration configuration = Bucket4j.configurationBuilder()
                                                              .addLimit(Bandwidth.simple(30, Duration.ofMinutes(1)))
                                                              .build();

    // cache for storing token buckets, where IP is key.
    @Inject
    private javax.cache.Cache&lt;String, GridBucketState&gt; cache;

    private ProxyManager&lt;String&gt; buckets;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
         // init bucket registry
         buckets = Bucket4j.extension(JCache.class).proxyManagerForCache(cache);
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest httpRequest = (HttpServletRequest) servletRequest;
        String ip = IpHelper.getIpFromRequest(httpRequest);

        // acquire cheap proxy to bucket
        Bucket bucket = buckets.getProxy(ip, configuration);

        // tryConsume returns false immediately if no tokens available with the bucket
        if (bucket.tryConsume(1)) {
            // the limit is not exceeded
            filterChain.doFilter(servletRequest, servletResponse);
        } else {
            // limit is exceeded
            HttpServletResponse httpResponse = (HttpServletResponse) servletResponse;
            httpResponse.setContentType("text/plain");
            httpResponse.setStatus(429);
            httpResponse.getWriter().append("Too many requests");
        }
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-2-limiting-access-to-service-by-contract-agreements"><a class="anchor" href="#example-2-limiting-access-to-service-by-contract-agreements"></a>3.1.2. Example 2 - limiting access to service by contract agreements</h4>
<div class="paragraph">
<p>Imagine that you provides paid language translation service via HTTP.
Each your user has unique agreement which differs from each other.
Details of each agreement is stored in relational database, and takes significant time to fetch(for example 100ms).
The example above will not work fine in this case, because time to create/fetch configuration of bucket from database
will be 100 times slower than limit-checking itself.
Bucket4j solves this problem via lazy configuration suppliers which are called if and only if bucket was not yet stored in grid,
thus it is possible to implement solution  that will read agreement from database once per each user.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class IpThrottlingFilter implements javax.servlet.Filter {

    // service to provide per user limits
    @Inject
    private LimitProvider limitProvider;

    // cache for storing token buckets, where IP is key.
    @Inject
    private javax.cache.Cache&lt;String, GridBucketState&gt; cache;

    private ProxyManager&lt;String&gt; buckets;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
         // init bucket registry
         buckets = Bucket4j.extension(JCache.class).proxyManagerForCache(cache);
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest httpRequest = (HttpServletRequest) servletRequest;
        String userId = AutentificationHelper.getUserIdFromRequest(httpRequest);

        // prepare configuration supplier which will be called(on first interaction with proxy) if bucket was not saved yet previously.
        Supplier&lt;BucketConfiguration&gt; configurationLazySupplier = getConfigSupplierForUser(userId);

        // acquire cheap proxy to bucket
        Bucket bucket = buckets.getProxy(ip, configurationLazySupplier);

        // tryConsume returns false immediately if no tokens available with the bucket
        if (bucket.tryConsume(1)) {
            // the limit is not exceeded
            filterChain.doFilter(servletRequest, servletResponse);
        } else {
            // limit is exceeded
            HttpServletResponse httpResponse = (HttpServletResponse) servletResponse;
            httpResponse.setContentType("text/plain");
            httpResponse.setStatus(429);
            httpResponse.getWriter().append("Too many requests");
        }
    }

    private Supplier&lt;BucketConfiguration&gt; getConfigSupplierForUser(String userId) {
         return () -&gt; {
             long translationsPerDay = limitProvider.readPerDayLimitFromAgreementsDatabase(userId);
             return Bucket4j.configurationBuilder()
                         .addLimit(Bandwidth.simple(translationsPerDay, Duration.ofDays(1)))
                         .build();
         };
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Question:</strong> is the provided JCache integration safe across multiple JVMs? Does it ensure that two nodes creating a bucket simultaneously on a given Cache&lt;K, V&gt; will only actually create one single bucket (without resetting a previously created one with the same key)?
<strong>Answer:</strong> Yes. JCache integration is safe for multi node environment, Bucket4j never replaces bucket which already exists.
This behavior is guaranteed by <strong>putIfAbsent</strong> method contract of [javax.cache.Cache](<a href="http://static.javadoc.io/javax.cache/cache-api/1.0.0/javax/cache/Cache.html" class="bare">http://static.javadoc.io/javax.cache/cache-api/1.0.0/javax/cache/Cache.html</a>) class.</p>
</div>
<div class="paragraph">
<p><strong>Question:</strong> Does ProxyManager store buckets internally, could be this a reason of OutOfMemoryError?
<strong>Answer:</strong> No. ProxyManager stores nothing about buckets which it returns, the buckets actually stored in in-memory GRID outside client JVM.
Think about proxy returned by <code>ProxyManager#getBucket</code> just about very cheap pointer to data which actually stored somewhere outside.
So, independently of count of buckets ProxyManager will never be a reason of crash or extreme memory consumption.</p>
</div>
<div class="paragraph">
<p><strong>Question:</strong> what will happen if bucket state will be lost in the GRID  because of split-brain, human mistake or pragmatically errors introduced by GRID vendor?
<strong>Answer:</strong> ProxyManager automatically detect this kind of situations and save bucket yet another time, to reconstruct bucket it uses provided configuration supplier.
Reconstructed bucket remembers nothing about previously consumed tokens, so limit can be exceeded in this kind of GRID failures.</p>
</div>
<div class="paragraph">
<p><strong>Question:</strong> should I always work with JCache through ProxyManager?
<strong>Answer:</strong> It depends. When you have deal with potentially huge and unpredictable amount of buckets, it is always better to use ProxyManager.
ProxyManager protects you from common performance pitfalls(like described in <a href="https://github.com/vladimir-bukhtoyarov/bucket4j/issues/26">this issue</a>).
But when you have deal with one or few buckets which well known at development time, then it would be better to avoid ProxyManager
and work directly with [GridBucket](<a href="https://github.com/vladimir-bukhtoyarov/bucket4j/blob/2.0/bucket4j-core/src/main/java/io/github/bucket4j/grid/GridBucket.java" class="bare">https://github.com/vladimir-bukhtoyarov/bucket4j/blob/2.0/bucket4j-core/src/main/java/io/github/bucket4j/grid/GridBucket.java</a>) as described in the next example.</p>
</div>
</div>
<div class="sect3">
<h4 id="example-3-working-with-jcache-without-proxymanager-abstraction"><a class="anchor" href="#example-3-working-with-jcache-without-proxymanager-abstraction"></a>3.1.3. Example 3 - working with JCache without ProxyManager abstraction</h4>
<div class="paragraph">
<p>Imagine yet another time that you develop WEB application and want to protect the whole cluster by 1000 requests per second, independently from request source,
in other words you need one single bucket which protects the system at whole. Lets create ServletFilter to check limits similar to <code>Example 1</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class GlobalThrottlingFilter implements javax.servlet.Filter {

    private static final String BUCKET_ID = "global-limit";

    @Inject
    private javax.cache.Cache&lt;String, GridBucketState&gt; cache;

    private Bucket bucket;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
         // create bucket
         bucket = Bucket4j.extension(JCache.class).builder()
             .addLimit(Bandwidth.simple(1000, Duration.ofSeconds(1)))
             .build(cache, BUCKET_ID, RecoveryStrategy.RECONSTRUCT);
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        // tryConsume returns false immediately if no tokens available with the bucket
        if (bucket.tryConsume(1)) {
            // the limit is not exceeded
            filterChain.doFilter(servletRequest, servletResponse);
        } else {
            // limit is exceeded
            HttpServletResponse httpResponse = (HttpServletResponse) servletResponse;
            httpResponse.setContentType("text/plain");
            httpResponse.setStatus(429);
            httpResponse.getWriter().append("Too many requests");
        }
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see the code is simpler when you work with Bucket directly without ProxyManager, so use this way always when all buckets are known at development time.</p>
</div>
</div>
<div class="sect3">
<h4 id="runnable-examples-of-jcache-integration"><a class="anchor" href="#runnable-examples-of-jcache-integration"></a>3.1.4. Runnable examples of JCache integration</h4>
<div class="paragraph">
<p>Bucket4j well tested with <code>Hazelcast</code> and <code>Apache Ignite/GridGain</code>, you can use integration tests from <a href="https://github.com/vladimir-bukhtoyarov/bucket4j/tree/2.0/bucket4j-jcache/src/test/java/io/github/bucket4j/grid/jcache">this folder</a> as live examples.</p>
</div>
</div>
<div class="sect3">
<h4 id="why-jcache-specification-is-not-enough-and-since-3-0-were-introduced-the-dedicated-modules-for-infinispan-hazelcast-and-ignite"><a class="anchor" href="#why-jcache-specification-is-not-enough-and-since-3-0-were-introduced-the-dedicated-modules-for-infinispan-hazelcast-and-ignite"></a>3.1.5. Why JCache specification is not enough and since 3.0 were introduced the dedicated modules for Infinispan, Hazelcast and Ignite?</h4>
<div class="paragraph">
<p>Asynchronous processing is very important for high-throughput applications, but JCache specification does not specify asynchronous API, because two early attempts to bring this kind functionality at spec level <a href="https://github.com/jsr107/jsr107spec/issues/307">307</a>, <a href="https://github.com/jsr107/jsr107spec/issues/312">312</a> were failed in absence of consensus.
Sad, but true, if you need for asynchronous API, then JCache extension is useless, and you need to choose from following extensions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>[bucket4j-ignite](ignite.md)</p>
</li>
<li>
<p>[bucket4j-hazelcast](hazelcast.md)</p>
</li>
<li>
<p>[bucket4j-infinispan](infinispan.md)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Of course implementation the asynchronous support for any other JCache provider outside from the list above should be easy exercise,
so feel free to return back the pull request addressed to cover your favorite JCache provider.</p>
</div>
</div>
<div class="sect3">
<h4 id="verification-of-compatibility-with-particular-jcache-provider-is-your-responsibility"><a class="anchor" href="#verification-of-compatibility-with-particular-jcache-provider-is-your-responsibility"></a>3.1.6. Verification of compatibility with particular JCache provider is your responsibility</h4>
<div class="paragraph">
<p>Keep in mind that there are many non-certified implementations of JCache specification on the market.
Many of them want to increase their popularity by declaring support for the JCache API,
but often only the API is supported and the semantic of JCache is totally ignored.
Usage Bucket4j with this kind of libraries should be completely avoided.</p>
</div>
<div class="paragraph">
<p>Bucket4j is only compatible with implementations which obey the JCache specification rules(especially related to EntryProcessor execution).
Oracle Coherence, Apache Ignite, Hazelcast are good examples of safe implementations of JCache.</p>
</div>
<div class="paragraph">
<p>Because it is impossible to test all possible JCache providers, you need to test your provider by yourself.
Just run this code in order to be sure that your implementation of JCache provides good isolation for EntryProcessors</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import javax.cache.Cache;
import javax.cache.processor.EntryProcessor;
import java.util.concurrent.CountDownLatch;
import java.io.Serializable;

public class CompatibilityTest {

    final Cache&lt;String, Integer&gt; cache;


    public CompatibilityTest(Cache&lt;String, Integer&gt; cache) {
        this.cache = cache;
    }

    public void test() throws InterruptedException {
        String key = "42";
        int threads = 4;
        int iterations = 1000;
        cache.put(key, 0);
        CountDownLatch latch = new CountDownLatch(threads);
        for (int i = 0; i &lt; threads; i++) {
            new Thread(() -&gt; {
                try {
                    for (int j = 0; j &lt; iterations; j++) {
                        EntryProcessor&lt;String, Integer, Void&gt; processor = (EntryProcessor&lt;String, Integer, Void&gt; &amp; Serializable) (mutableEntry, objects) -&gt; {
                            int value = mutableEntry.getValue();
                            mutableEntry.setValue(value + 1);
                            return null;
                        };
                        cache.invoke(key, processor);
                    }
                } finally {
                    latch.countDown();
                }
            }).start();
        }
        latch.await();
        int value = cache.get(key);
        if (value == threads * iterations) {
            System.out.println("Implementation which you use is compatible with Bucket4j");
        } else {
            String msg = "Implementation which you use is not compatible with Bucket4j";
            msg += ", " + (threads * iterations - value) + " writes are missed";
            throw new IllegalStateException(msg);
        }
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The check does 4000 increments of integer in parallel and verifies that no one update has been missed.
If check passed then your JCache provider is compatible with Bucket4j, the throttling will work fine in distributed and concurrent environment.
If check is not passed, then reach to the particular JCache provider team and consult why its implementation misses the writes.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hazelcast-integration"><a class="anchor" href="#hazelcast-integration"></a>3.2. Hazelcast integration</h3>
<div class="paragraph">
<p>Before use <code>bucket4j-hazelcast</code> module please read [bucket4j-jcache documentation](jcache-usage.md),
because <code>bucket4j-hazelcast</code> is just a follow-up of <code>bucket4j-jcache</code>.</p>
</div>
<div class="paragraph">
<p><strong>Question:</strong> Bucket4j already supports JCache since version <code>1.2</code>. Why it was needed to introduce direct support for <code>Hazelcast</code>?
<strong>Answer:</strong> Because <a href="https://www.jcp.org/en/jsr/detail?id=107">JCache API (JSR 107)</a> does not specify asynchronous API,
developing the dedicated module <code>bucket4j-hazelcast</code> was the only way to provide asynchrony for users who use <code>Bucket4j</code> and <code>Hazelcast</code> together.</p>
</div>
<div class="paragraph">
<p><strong>Question:</strong> Should I migrate from <code>bucket4j-jcache</code> to <code>bucket4j-hazelcast</code> If I do not need in asynchronous API?
<strong>Answer:</strong> No, you should not migrate to <code>bucket4j-hazelcast</code> in this case.</p>
</div>
<div class="sect3">
<h4 id="dependencies"><a class="anchor" href="#dependencies"></a>3.2.1. Dependencies</h4>
<div class="paragraph">
<p>To use Bucket4j extension for Hazelcast with <code>Hazelcast 4.x</code> you need to add following dependency:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.github.vladimir-bukhtoyarov&lt;/groupId&gt;
    &lt;artifactId&gt;bucket4j-hazelcast&lt;/artifactId&gt;
    &lt;version&gt;7.0.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are using legacy version of Hazelcast <code>3.x</code> then you need to add following dependency:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.github.vladimir-bukhtoyarov&lt;/groupId&gt;
    &lt;artifactId&gt;bucket4j-hazelcast-3&lt;/artifactId&gt;
    &lt;version&gt;7.0.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="general-compatibility-matrix-principles"><a class="anchor" href="#general-compatibility-matrix-principles"></a>3.2.2. General compatibility matrix principles:</h4>
<div class="ulist">
<ul>
<li>
<p>Bucket4j authors do not perform continues monitoring of new Hazelcast releases. So, there is can be case when there is no one version of Bucket4j which is compatible with newly released Hazelcast,
just log issue to <a href="https://github.com/vladimir-bukhtoyarov/bucket4j/issues">bug tracker</a> in this case, adding support to new version of Hazelcast is usually easy exercise.</p>
</li>
<li>
<p>Integrations with legacy versions of Hazelcast are not removed without a clear reason. Hence You are in safety, even you are working in a big enterprise company that does not update its infrastructure frequently because You still get new Bucket4j&#8217;s features even for legacy Hazelcast&#8217;s releases.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="example-of-bucket-instantiation"><a class="anchor" href="#example-of-bucket-instantiation"></a>3.2.3. Example of Bucket instantiation</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">IMap&lt;K, GridBucketState&gt; map = ...;
...

Bucket bucket = Bucket4j.extension(Hazelcast.class).builder()
                   .addLimit(Bandwidth.simple(1_000, Duration.ofMinutes(1)))
                   .build(map, key, RecoveryStrategy.RECONSTRUCT);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-of-proxymanager-instantiation"><a class="anchor" href="#example-of-proxymanager-instantiation"></a>3.2.4. Example of ProxyManager instantiation</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">IMap&lt;K, GridBucketState&gt; map = ...;
...

ProxyManager proxyManager = Bucket4j.extension(Hazelcast.class).proxyManagerForMap(map);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-custom-serialization-for-bucket4j-library-classes"><a class="anchor" href="#configuring-custom-serialization-for-bucket4j-library-classes"></a>3.2.5. Configuring Custom Serialization for Bucket4j library classes</h4>
<div class="paragraph">
<p>If you configure nothing, then by default Java serialization will be used for serialization Bucket4j library classes. Java serialization can be rather slow and should be avoided in general.
<code>Bucket4j</code> provides <a href="https://docs.hazelcast.org/docs/3.0/manual/html/ch03s03.html">custom serializers</a> for all library classes that could be transferred over network.
To let Hazelcast know about fast serializers you should register them programmatically in the serialization config:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import com.hazelcast.config.Config;
import com.hazelcast.config.SerializationConfig;
import com.hazelcast.config.SerializerConfig;
import io.github.bucket4j.grid.hazelcast.serialization.HazelcastSerializer;
...
    Config config = ...
    SerializationConfig serializationConfig = config.getSerializationConfig();

    // the starting type ID number for Bucket4j classes.
    // you free to choose any unused ID, but be aware that Bucket4j uses 2 types currently,
    // and may use more types in the future, so leave enough empty space after baseTypeIdNumber
    int baseTypeIdNumber = 10000;

    HazelcastSerializer.addCustomSerializers(serializationConfig, baseTypeIdNumber);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="known-issues-related-with-docker-andor-springboot"><a class="anchor" href="#known-issues-related-with-docker-andor-springboot"></a>4. Known issues related with Docker and(or) SpringBoot</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>[#186 HazelcastEntryProcessorAdapter class not found](<a href="https://github.com/vladimir-bukhtoyarov/bucket4j/discussions/186" class="bare">https://github.com/vladimir-bukhtoyarov/bucket4j/discussions/186</a>) - check file permissins inside your image.</p>
</li>
<li>
<p>[#182 HazelcastSerializationException with Hazelcast 4.2](<a href="https://github.com/vladimir-bukhtoyarov/bucket4j/issues/162" class="bare">https://github.com/vladimir-bukhtoyarov/bucket4j/issues/162</a>) - properly setup classloader for Hazelcast client configuration.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="apache-ignite-integration"><a class="anchor" href="#apache-ignite-integration"></a>4.1. Apache Ignite integration</h3>
<div class="paragraph">
<p>Before use <code>bucket4j-ignite</code> module please read [bucket4j-jcache documentation](jcache-usage.md),
because <code>bucket4j-ignite</code> is just a follow-up of <code>bucket4j-jcache</code>.</p>
</div>
<div class="paragraph">
<p>Bucket4j supports Ignite Thin-Client as well as regular deployment scenario.</p>
</div>
<div class="paragraph">
<p><strong>Question:</strong> Bucket4j already supports JCache since version <code>1.2</code>. Why it was needed to introduce direct support for <code>Apache Ignite</code>?
<strong>Answer:</strong> Because <a href="https://www.jcp.org/en/jsr/detail?id=107">JCache API (JSR 107)</a> does not specify asynchronous API,
developing the dedicated module <code>bucket4j-ignite</code> was the only way to provide asynchrony for users who use <code>Bucket4j</code> and <code>Apache Ignite</code> together.</p>
</div>
<div class="paragraph">
<p><strong>Question:</strong> Should I migrate from <code>bucket4j-jcache</code> to <code>bucketj-ignite</code> If I do not need in asynchronous API?
<strong>Answer:</strong> No, you should not migrate to <code>bucketj-ignite</code> in this case.</p>
</div>
<div class="sect3">
<h4 id="dependencies-2"><a class="anchor" href="#dependencies-2"></a>4.1.1. Dependencies</h4>
<div class="paragraph">
<p>To use <code>bucket4j-ignite</code> extension you need to add following dependency:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.github.vladimir-bukhtoyarov&lt;/groupId&gt;
    &lt;artifactId&gt;bucket4j-ignite&lt;/artifactId&gt;
    &lt;version&gt;7.0.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-of-bucket-instantiation-2"><a class="anchor" href="#example-of-bucket-instantiation-2"></a>4.1.2. Example of Bucket instantiation</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">org.apache.ignite.IgniteCache&lt;K, GridBucketState&gt; cache = ...;
...

Bucket bucket = Bucket4j.extension(io.github.bucket4j.grid.ignite.Ignite.class).builder()
                   .addLimit(Bandwidth.simple(1_000, Duration.ofMinutes(1)))
                   .build(cache, key, RecoveryStrategy.RECONSTRUCT);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-of-proxymanager-instantiation-2"><a class="anchor" href="#example-of-proxymanager-instantiation-2"></a>4.1.3. Example of ProxyManager instantiation</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">org.apache.ignite.IgniteCache&lt;K, GridBucketState&gt; cache = ...;
...

ProxyManager proxyManager = Bucket4j.extension(io.github.bucket4j.grid.ignite.Ignite.class).proxyManagerForCache(cache);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-of-bucket-instantiation-via-thin-client"><a class="anchor" href="#example-of-bucket-instantiation-via-thin-client"></a>4.1.4. Example of Bucket instantiation via Thin Client</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">org.apache.ignite.client.ClientCache&lt;K, GridBucketState&gt; cache = ...;
org.apache.ignite.client.ClientCompute clientCompute = ...;

...

Bucket bucket = Bucket4j.extension(io.github.bucket4j.grid.ignite.Ignite.class).builder()
                   .addLimit(Bandwidth.simple(1_000, Duration.ofMinutes(1)))
                   .build(clientCompute, cache, key, RecoveryStrategy.RECONSTRUCT);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-of-proxymanager-instantiation-via-thin-client"><a class="anchor" href="#example-of-proxymanager-instantiation-via-thin-client"></a>4.1.5. Example of ProxyManager instantiation via Thin Client</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">org.apache.ignite.client.ClientCache&lt;K, GridBucketState&gt; cache = ...;
org.apache.ignite.client.ClientCompute clientCompute = ...;
...

ProxyManager proxyManager = Bucket4j.extension(io.github.bucket4j.grid.ignite.Ignite.class).proxyManagerForCache(clientCompute, cache);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="infinispan-integration"><a class="anchor" href="#infinispan-integration"></a>4.2. Infinispan integration</h3>
<div class="paragraph">
<p>Before use <code>bucket4j-infinispan</code> module please read [bucket4j-jcache documentation](jcache-usage.md),
because <code>bucket4j-infinispan</code> is just a follow-up of <code>bucket4j-jcache</code>.</p>
</div>
<div class="paragraph">
<p><strong>Question:</strong> Bucket4j already supports JCache since version <code>1.2</code>. Why it was needed to introduce direct support for <code>Infinispan</code>?
<strong>Answer:</strong> When you want to use Bucket4j together with Infinispan, you must always use <code>bucket4j-infinispan</code> module instead of <code>bucket4j-jcache</code>,
because Infinispan does not provide mutual exclusion for entry-processors. Any attempt to use Infinispan via <code>bucket4j-jcache</code> will be failed with UnsupportedOperationException exception
at bucket construction time.</p>
</div>
<div class="sect3">
<h4 id="dependencies-3"><a class="anchor" href="#dependencies-3"></a>4.2.1. Dependencies</h4>
<div class="paragraph">
<p>To use <code>bucket4j-infinispan</code> with <code>Infinispan 9.x, 10.x</code> extension you need to add following dependency:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.github.vladimir-bukhtoyarov&lt;/groupId&gt;
    &lt;artifactId&gt;bucket4j-infinispan&lt;/artifactId&gt;
    &lt;version&gt;7.0.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are using legacy version of Infinispan <code>8.x</code> then you need to add following dependency:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.github.vladimir-bukhtoyarov&lt;/groupId&gt;
    &lt;artifactId&gt;bucket4j-infinispan-8&lt;/artifactId&gt;
    &lt;version&gt;7.0.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="general-compatibility-matrix-principles-2"><a class="anchor" href="#general-compatibility-matrix-principles-2"></a>4.2.2. General compatibility matrix principles::</h4>
<div class="ulist">
<ul>
<li>
<p>Bucket4j authors do not perform continues monitoring of new Infinispan releases. So, there is can be case when there is no one version of Bucket4j which is compatible with newly released Infinispan,
just log issue to <a href="https://github.com/vladimir-bukhtoyarov/bucket4j/issues">bug tracker</a> in this case, adding support to new version of Infinispan is usually easy exercise.</p>
</li>
<li>
<p>Integrations with legacy versions of Infinispan are not removed without a clear reason. Hence You are in safety, even you are working in a big enterprise company that does not update its infrastructure frequently because You still get new Bucket4j&#8217;s features even for legacy Infinispan&#8217;s releases.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="special-notes-for-infinispan-10-0"><a class="anchor" href="#special-notes-for-infinispan-10-0"></a>4.2.3. Special notes for Infinispan 10.0+</h4>
<div class="paragraph">
<p>As mentioned in the <a href="https://infinispan.org/docs/dev/titles/developing/developing.html#marshalling">Infinispan Marshalling documentation</a>, since release <code>10.0.0</code> Infinispan does not allow deserialization of custom payloads into Java classes.
If you do not configure serialization(as described bellow), you will get the error like this on any attempt to use Bucket4j with brand new Infinispan release:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">Jan 02, 2020 4:57:56 PM org.infinispan.marshall.persistence.impl.PersistenceMarshallerImpl objectToBuffer
WARN: ISPN000559: Cannot marshall 'class io.github.bucket4j.grid.infinispan.SerializableFunctionAdapter'
java.lang.IllegalArgumentException: No marshaller registered for Java type io.github.bucket4j.grid.infinispan.SerializableFunctionAdapter
	at org.infinispan.protostream.impl.SerializationContextImpl.getMarshallerDelegate(SerializationContextImpl.java:279)
	at org.infinispan.protostream.WrappedMessage.writeMessage(WrappedMessage.java:240)
	at org.infinispan.protostream.ProtobufUtil.toWrappedStream(ProtobufUtil.java:196)</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are three options to solve this problem:
* Configure Jboss marshalling instead of default ProtoStream marshaller as described <a href="https://infinispan.org/docs/dev/titles/developing/developing.html#jboss_marshalling">there</a>.
* Configure Java Serialization Marshaller instead of default ProtoStream marshaller, as described <a href="https://infinispan.org/docs/dev/titles/developing/developing.html#java_serialization_marshaller">there</a>.
Do not forget to add <code>io.github.bucket4j.*</code> regexp to the whitelist if choosing this way.
* And last way(recommended) just register <code>Bucket4j serialization context initializer</code> in the serialization configuration.
You can do it in both programmatically and declarative ways:</p>
</div>
<div class="paragraph">
<p><strong>Programmatic registration of Bucket4jProtobufContextInitializer</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.github.bucket4j.grid.infinispan.serialization.Bucket4jProtobufContextInitializer;
import org.infinispan.configuration.global.GlobalConfigurationBuilder;
...
GlobalConfigurationBuilder builder = new GlobalConfigurationBuilder();
builder.serialization().addContextInitializer(new Bucket4jProtobufContextInitializer());</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Declarative registration of Bucket4jProtobufContextInitializer</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;serialization&gt;
    &lt;context-initializer class="io.github.bucket4j.grid.infinispan.serialization.Bucket4jProtobufContextInitializer"/&gt;
&lt;/serialization&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>And that is all. Just registering <code>Bucket4jProtobufContextInitializer</code> in any way is enough to make Bucket4j compatible with ProtoStream marshaller, you do not have to care about *.proto files, annotations, whitelist etc,
all neccessary Protobuffers configs generated by <code>Bucket4jProtobufContextInitializer</code> and registerd on the fly.</p>
</div>
</div>
<div class="sect3">
<h4 id="example-of-bucket-instantiation-3"><a class="anchor" href="#example-of-bucket-instantiation-3"></a>4.2.4. Example of Bucket instantiation</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">org.infinispan.functional.FunctionalMap.ReadWriteMap&lt;K, GridBucketState&gt; map = ...;
...
Bucket bucket = Bucket4j.extension(Infinispan.class).builder()
                   .addLimit(Bandwidth.simple(1_000, Duration.ofMinutes(1)))
                   .build(map, key, RecoveryStrategy.RECONSTRUCT);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-of-proxymanager-instantiation-3"><a class="anchor" href="#example-of-proxymanager-instantiation-3"></a>4.2.5. Example of ProxyManager instantiation</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">org.infinispan.functional.FunctionalMap.ReadWriteMap&lt;K, GridBucketState&gt; map = ...;
...

ProxyManager proxyManager = Bucket4j.extension(Infinispan.class).proxyManagerForMap(map);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="oracle-coherence-integration"><a class="anchor" href="#oracle-coherence-integration"></a>4.3. Oracle Coherence integration</h3>
<div class="paragraph">
<p>Before use <code>bucket4j-coherence</code> module please read [bucket4j-jcache documentation](jcache-usage.md),
because <code>bucket4j-coherence</code> is just a follow-up of <code>bucket4j-jcache</code>.</p>
</div>
<div class="paragraph">
<p><strong>Question:</strong> Bucket4j already supports JCache since version <code>1.2</code>. Why it was needed to introduce direct support for <code>Oracle Coherence</code>?
<strong>Answer:</strong> Because <a href="https://www.jcp.org/en/jsr/detail?id=107">JCache API (JSR 107)</a> does not specify asynchronous API,
developing the dedicated module <code>bucket4j-coherence</code> was the only way to provide asynchrony for users who use <code>Bucket4j</code> and <code>Oracle Coherence</code> together.</p>
</div>
<div class="paragraph">
<p><strong>Question:</strong> Should I migrate from <code>bucket4j-jcache</code> to <code>bucketj-coherence</code> If I do not need in asynchronous API?
<strong>Answer:</strong> No, you should not migrate to <code>bucketj-coherence</code> in this case.</p>
</div>
<div class="sect3">
<h4 id="dependencies-4"><a class="anchor" href="#dependencies-4"></a>4.3.1. Dependencies</h4>
<div class="paragraph">
<p>To use <code>bucket4j-coherence</code> extension you need to add following dependency:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.github.vladimir-bukhtoyarov&lt;/groupId&gt;
    &lt;artifactId&gt;bucket4j-coherence&lt;/artifactId&gt;
    &lt;version&gt;7.0.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-of-bucket-instantiation-4"><a class="anchor" href="#example-of-bucket-instantiation-4"></a>4.3.2. Example of Bucket instantiation</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">com.tangosol.net.NamedCache&lt;K, GridBucketState&gt; cache = ...;
...

Bucket bucket = Bucket4j.extension(Coherence.class).builder()
                   .addLimit(Bandwidth.simple(1_000, Duration.ofMinutes(1)))
                   .build(cache, key, RecoveryStrategy.RECONSTRUCT);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-of-proxymanager-instantiation-4"><a class="anchor" href="#example-of-proxymanager-instantiation-4"></a>4.3.3. Example of ProxyManager instantiation</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">com.tangosol.net.NamedCache&lt;K, GridBucketState&gt; cache = ...;

ProxyManager proxyManager = Bucket4j.extension(Coherence.class).proxyManagerForCache(cache);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-pof-serialization-for-bucket4j-library-classes"><a class="anchor" href="#configuring-pof-serialization-for-bucket4j-library-classes"></a>4.3.4. Configuring POF serialization for Bucket4j library classes</h4>
<div class="paragraph">
<p>If you configure nothing, then by default Java serialization will be used for serialization Bucket4j library classes. Java serialization can be rather slow and should be avoided in general.
<code>Bucket4j</code> provides <a href="https://docs.oracle.com/cd/E24290_01/coh.371/e22837/api_pof.htm#COHDG1363">custom POF serializers</a> for all library classes that could be transferred over network.
To let Coherence know about POF serializers you should register three serializers in the POF configuration config file:
* <code>CoherenceEntryProcessorAdapterPofSerializer</code> for class <code>CoherenceEntryProcessorAdapter</code>
* <code>GridBucketStatePofSerializer</code> for class <code>GridBucketState</code>
* <code>CommandResultPofSerializer</code> for class <code>CommandResult</code></p>
</div>
<div class="paragraph">
<p><strong>Example of POF serialization:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;pof-config xmlns="http://xmlns.oracle.com/coherence/coherence-pof-config"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://xmlns.oracle.com/coherence/coherence-pof-config coherence-pof-config.xsd"&gt;

    &lt;user-type-list&gt;
        &lt;!-- Include default Coherence types --&gt;
        &lt;include&gt;coherence-pof-config.xml&lt;/include&gt;

        &lt;!-- Define serializers for Bucket4j classes --&gt;
        &lt;user-type&gt;
            &lt;type-id&gt;1001&lt;/type-id&gt;
            &lt;class-name&gt;io.github.bucket4j.grid.coherence.CoherenceEntryProcessorAdapter&lt;/class-name&gt;
            &lt;serializer&gt;
                &lt;class-name&gt;io.github.bucket4j.grid.coherence.pof.CoherenceEntryProcessorAdapterPofSerializer&lt;/class-name&gt;
            &lt;/serializer&gt;
        &lt;/user-type&gt;
        &lt;user-type&gt;
            &lt;type-id&gt;1002&lt;/type-id&gt;
            &lt;class-name&gt;io.github.bucket4j.grid.GridBucketState&lt;/class-name&gt;
            &lt;serializer&gt;
                &lt;class-name&gt;io.github.bucket4j.grid.coherence.pof.GridBucketStatePofSerializer&lt;/class-name&gt;
            &lt;/serializer&gt;
        &lt;/user-type&gt;
        &lt;user-type&gt;
            &lt;type-id&gt;1003&lt;/type-id&gt;
            &lt;class-name&gt;io.github.bucket4j.grid.CommandResult&lt;/class-name&gt;
            &lt;serializer&gt;
                &lt;class-name&gt;io.github.bucket4j.grid.coherence.pof.CommandResultPofSerializer&lt;/class-name&gt;
            &lt;/serializer&gt;
        &lt;/user-type&gt;
    &lt;/user-type-list&gt;
&lt;/pof-config&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Double check with <a href="https://docs.oracle.com/cd/E24290_01/coh.371/e22837/api_pof.htm#COHDG5182">official Oracle Coherence documentation</a> in case of any questions related to <code>Portable Object Format</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="asynchronous-api"><a class="anchor" href="#asynchronous-api"></a>4.4. Asynchronous API</h3>
<div class="paragraph">
<p>Since version <code>3.0</code> Bucket4j provides asynchronous analogs for majority of API methods.
Async view of bucket is availble through <code>asAsync()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Bucket bucket = ...;
AsyncBucket asyncBucket = bucket.asAsync();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each method of class [AsyncBucket](<a href="https://github.com/vladimir-bukhtoyarov/bucket4j/blob/3.1/bucket4j-core/src/main/java/io/github/bucket4j/AsyncBucket.java" class="bare">https://github.com/vladimir-bukhtoyarov/bucket4j/blob/3.1/bucket4j-core/src/main/java/io/github/bucket4j/AsyncBucket.java</a>)
 has full equivalence with same semantic in synchronous version in the [Bucket](<a href="https://github.com/vladimir-bukhtoyarov/bucket4j/blob/3.0/bucket4j-core/src/main/java/io/github/bucket4j/Bucket.java" class="bare">https://github.com/vladimir-bukhtoyarov/bucket4j/blob/3.0/bucket4j-core/src/main/java/io/github/bucket4j/Bucket.java</a>) class.</p>
</div>
<div class="sect3">
<h4 id="example-limiting-the-rate-of-access-to-asynchronous-servlet"><a class="anchor" href="#example-limiting-the-rate-of-access-to-asynchronous-servlet"></a>4.4.1. Example - limiting the rate of access to asynchronous servlet</h4>
<div class="paragraph">
<p>Imagine that you develop SMS service, which allows send SMS via HTTP interface.
You want from your architecture to be protected from overloading, clustered and fully asynchronous.</p>
</div>
<div class="paragraph">
<p><strong>Overloading protection requirement:</strong></p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>To prevent fraud and service overloading you want to introduce following limit for any outbound phone number: The bucket size is 20 SMS (which cannot be exceeded at any given time), with a "refill rate" of 10 SMS per minute that continually increases tokens in the bucket.
In other words, if client sends 10 SMS per minute, it will never be throttled,
and moreover client have overdraft equals to 20 SMS which can be used if average is little bit higher that 10 SMS/minute on short time period.
<strong>Solution:</strong> lets use bucket4j for this.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p><strong>Clustering requirement:</strong></p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>You want to avoid the single point of failure, if one server crashed that information about consumed tokens should not be lost,
thus it would be better to use any distributed computation platform for storing the buckets.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p><strong>Solution:</strong> lets use JBoss Infinispan for this and <code>bucket4j-infinispan</code> extension.
Hazelcast and Apache Ignite will be also well choice, Infinispan just selected as example.</p>
</div>
<div class="paragraph">
<p><strong>Asynchronous processing requirement:</strong>
Also for maximum scalability you want from architecture to be fully non-blocking,
non-blocking architecture means that both SMS sending and limit checking should be asynchronous.
<strong>Solution:</strong> lets use asynchronous features provided by bucket4j and Servlet-API.</p>
</div>
<div class="paragraph">
<p><strong>Mockup of service based on top of Servlet API and bucket4j-infinispan</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SmsServlet extends javax.servlet.http.HttpServlet {

    private SmsSender smsSender;
    private ProxyManager&lt;String&gt; buckets;
    private Supplier&lt;BucketConfiguration&gt; configuration;

    @Override
    public void init(ServletConfig config) throws ServletException {
        super.init(config);
        ServletContext ctx = config.getServletContext();

        smsSender = (SmsSender) ctx.getAttribute("sms-sender");

        FunctionalMapImpl&lt;String, GridBucketState&gt; bucketMap = (FunctionalMapImpl&lt;String, GridBucketState&gt;) ctx.getAttribute("bucket-map");
        this.buckets = Bucket4j.extension(Infinispan.class).proxyManagerForMap(bucketMap);

        this.configuration = () -&gt; {
            long overdraft = 20;
            Refill refill = Refill.greedy(10, Duration.ofMinutes(1));
            Bandwidth limit = Bandwidth.classic(overdraft, refill);
            return Bucket4j.configurationBuilder()
                .addLimit(limit)
                .build();
        };
    }

    @Override
    protected void doPost(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest httpRequest = (HttpServletRequest) servletRequest;

        String fromNumber = req.getParameter("from");
        String toNumber = req.getParameter("to");
        String text = req.getParameter("text");

        Bucket bucket = buckets.getProxy(fromNumber, configuration);
        CompletableFuture&lt;ConsumptionProbe&gt; limitCheckingFuture = bucket.asAsync().tryConsumeAndReturnRemaining(1);
        final AsyncContext asyncContext = req.startAsync();
        limitCheckingFuture.thenCompose(probe -&gt; {
            if (!probe.isConsumed()) {
                Result throttledResult = Result.throttled(probe);
                return CompletableFuture.completedFuture(throttledResult);
            } else {
                CompletableFuture&lt;Result&gt; sendingFuture = smsSender.sendAsync(fromNumber, toNumber, text);
                return sendingFuture;
            }
        }).whenComplete((result, exception) -&gt; {
            HttpServletResponse asyncResponse = (HttpServletResponse) asyncContext.getResponse();
            try {
                asyncResponse.setContentType("text/plain");
                if (exception != null || result.isFailed()) {
                    asyncResponse.setStatus(500);
                    asyncResponse.getWriter().println("Internal Error");
                } else if (result.isThrottled()) {
                    asyncResponse.setStatus(429);
                    asyncResponse.setHeader("X-Rate-Limit-Retry-After-Seconds", "" + result.getRetryAfter());
                    asyncResponse.getWriter().append("Too many requests");
                } else {
                    asyncResponse.setStatus(200);
                    asyncResponse.getWriter().append("Success");
                }
            } finally{
                asyncContext.complete();
            }
        });
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="production-checklist-especially-in-the-context-of-distributed-systems"><a class="anchor" href="#production-checklist-especially-in-the-context-of-distributed-systems"></a>4.5. Production checklist especially in the context of distributed systems</h3>
<div class="paragraph">
<p>Before using Bucket4j in clustered scenario you need to understand, agree and configure following points:</p>
</div>
<div class="paragraph">
<div class="title">Do not forget about exception handling</div>
<p>When working within a distributed system, it is innevitable that requests may cross the border of the current JVM, leading to a communication on the network.
Network being unreliable, it is impossible to avoid failures. Thus you should embrace this reality and be ready to get unchecked exceptions when interacting with a distributed bucket.
<strong>It is your responsibility to handle(or ignore) such exceptions:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>You probably do not want to fail business transactions if the grid responsible for throttling goes down. If this is the case you can simply log the exception and continue your business transaction without throttling</p>
</li>
<li>
<p>If you wish to fail your business transaction when the grid responsible for throttling goes down, simply rethrow or don&#8217;t catch the exception</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">Do not forget to configure backups</div>
<p>If the state of any bucket should survive the restart/crash of grid node that holds its state, you need to configure backups yourself, in way specific to the particular grid vendor. For example, see how to <a href="https://apacheignite.readme.io/v2.3/docs/primary-and-backup-copies">configure backups for Apache Ignite</a>.</p>
</div>
<div class="paragraph">
<div class="title">Retention tuning is your responsibility</div>
<p>When dealing with multi-tenant scenarios like a bucket per user or a bucket per IP address,
the amount of buckets in the cache will continuously increase. This is because a new bucket will be created each time a new key is detected.
To prevent exhausting the available memory of your cluster you need to configure following aspects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Expiration since last access</strong> - in order to allow the grid to remove the keys which haven&#8217;t been used in a long time. For example, see how to <a href="https://apacheignite.readme.io/docs/expiry-policies">configure expiration policy for Apache Ignite</a>.</p>
</li>
<li>
<p><strong>Maximum cache size(in units or bytes)</strong> - Obviously it is preferable to lose bucket data than lose the whole cluster due to out of memory exception.</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">High availability(HA) tuning and testing is your responsibility</div>
<p>There are no special settings for HA supported by Bucket4j, because Bucket4j does nothing more that just invoking EntryProcessors on the cache.
Instead Bucket4j relies on <strong>you</strong> to configure the cache with proper parameters that control redundancy and high availability.</p>
</div>
<div class="paragraph">
<p>Years of experience working with distributed system has tought the author that High Availability does not come for free. You need to test and verify that your system remains available. This cannot be provided by this or any other library. Your system will most certainly go down if you do not plan for that.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="advanced-features"><a class="anchor" href="#advanced-features"></a>5. Advanced features</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="listener"><a class="anchor" href="#listener"></a>5.1. Listening for bucket events</h3>
<div class="sect3">
<h4 id="what-can-be-listened"><a class="anchor" href="#what-can-be-listened"></a>5.1.1. What can be listened</h4>
<div class="ulist">
<div class="title">You can decorate the bucket by listener in order to track following events:</div>
<ul>
<li>
<p>When tokens consumed from bucket.</p>
</li>
<li>
<p>When consumption requests was rejected by bucket.</p>
</li>
<li>
<p>When thread was parked for wait of tokens refill in result of interaction with <code>BlockingBucket</code>.</p>
</li>
<li>
<p>When thread was interrupted during the wait of tokens refill  in result of interaction with <code>BlockingBucket</code>.</p>
</li>
<li>
<p>When delayed task was submit to <code>ScheduledExecutorService</code> in result of interaction with <code>AsyncScheduledBucket</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="listener-api-corner-cases"><a class="anchor" href="#listener-api-corner-cases"></a>5.1.2. Listener API - corner cases</h4>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><strong>Question:</strong> How many listeners is need to create in case of application uses many buckets?</p>
</div>
<div class="paragraph">
<p><strong>Answer:</strong>  it depends:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If you want to have aggregated statistics for all buckets then create single listener per application and reuse this listener for all buckets.</p>
</li>
<li>
<p>If you want to measure statistics independently per each bucket then use listener per bucket model.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><strong>Question:</strong> where is methods of listener are invoking in case of distributed usage?</p>
</div>
<div class="paragraph">
<p><strong>Answer:</strong> listener always invoked on client side, it is means that each client JVM will have own totally independent stat for same bucket.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p><strong>Question:</strong> Why does bucket invoke the listener on client side instead of server side in case of distributed scenario? What I need to do if I need in aggregated stat across the whole cluster?</p>
</div>
<div class="paragraph">
<p><strong>Answer:</strong> Because of planned expansion to non-JVM back-ends such as Redis, MySQL, PostgreSQL.
It is not possible to serialize and invoke listener on this non-java back-ends, so it was decided to invoke listener on client side,
in order to avoid inconsistency between different back-ends in the future.
You can do post-aggregation of monitoring statistics via features built-into your monitoring database or via mediator(like StatsD) between your application and monitoring database.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="how-to-attach-listener-to-bucket"><a class="anchor" href="#how-to-attach-listener-to-bucket"></a>5.1.3. How to attach listener to bucket?</h4>
<div class="paragraph">
<p>The bucket can be decorated by listener via <code>toListenable</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">BucketListener listener = new MyListener();

Bucket bucket = Bucket4j.builder()
                    .addLimit(Bandwidth.simple(100, Duration.ofMinutes(1)))
                    .build()
                    .toListenable(listener);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="example-of-integration-with-dropwizard-metrics-core"><a class="anchor" href="#example-of-integration-with-dropwizard-metrics-core"></a>5.1.4. Example of integration with Dropwizard metrics-core</h4>
<div class="paragraph">
<p><code>io.github.bucket4j.SimpleBucketListener</code> is simple implementation of <code>io.github.bucket4j.BucketListener</code> interface that available out of the box. Bellow the example of exposing statistics via Dropwizard Metrics(for Micrometer it should be quite similar):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static Bucket decorateBucketByStatListener(Bucket originalBucket, String bucketName, MetricRegistry registry) {
  SimpleBucketListener stat = new SimpleBucketListener();
  registry.register(name + ".consumed", (Gauge&lt;Long&gt;) stat::getConsumed);
  registry.register(name + ".rejected", (Gauge&lt;Long&gt;) stat::getRejected);
  registry.register(name + ".parkedNanos", (Gauge&lt;Long&gt;) stat::getParkedNanos);
  registry.register(name + ".interrupted", (Gauge&lt;Long&gt;) stat::getInterrupted);
  registry.register(name + ".delayedNanos", (Gauge&lt;Long&gt;) stat::getDelayedNanos);

  return originalBucket.toListenable(stat);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="verbose-api"><a class="anchor" href="#verbose-api"></a>5.2. Verbose API</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Verbose API</dt>
<dd>
<p>is the API which intent is in injecting low-level diagnostic information into results of any interaction with bucket. Verbose API providing the same functionality as Regular API, with one exception - result of any method always decorated by <code>VerboseResult</code> wrapper.</p>
</dd>
<dt class="hdlist1">VerboseResult</dt>
<dd>
<p>is the wrapper for interaction result that provides the snapshot of bucket and its configuration that was actual at the moment of interaction with bucket.</p>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="verbose-api-entry-points"><a class="anchor" href="#verbose-api-entry-points"></a>5.2.1. Verbose API entry-points</h4>
<div class="paragraph">
<p>The way to get access for <code>Verbose API</code> is the same for all type of buckets, just call <code>asVerbose()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// for io.github.bucket4j.Bucket
Bucket bucket = ...;
bucket.asVerbose();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// for io.github.bucket4j.Bucket
Bucket bucket = ...;
VerboseBucket verboseBucket = bucket.asVerbose();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// for io.github.bucket4j.distributed.BucketProxy
BucketProxy bucket = ...;
VerboseBucket verboseBucket = bucket.asVerbose();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// for io.github.bucket4j.distributed.AsyncBucketProxy
AsyncBucketProxy bucket = ...;
AsyncVerboseBucket verboseBucket = bucket.asVerbose();</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
BlockingBucket and ScheduledBucket do not provide the verbose analogs. VerboseResult has no sense for this kind of buckets because interactions with them can be followed by thread sleep or delayed execution, so VerboseResult can be absolutely stale and irrelevant to the moment of time when control over execution is being returned to your code.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="principles-of-result-decoration"><a class="anchor" href="#principles-of-result-decoration"></a>5.2.2. Principles of result decoration</h4>
<div class="ulist">
<ul>
<li>
<p>void return type always decorated by <code>VerboseResult&lt;Void&gt;</code></p>
</li>
<li>
<p>A primitive result type like long, boolean always decorated by correspondent boxed type for example <code>VerboseResult&lt;Boolean&gt;</code></p>
</li>
<li>
<p>None primitive reult type always decorated as is, for example <code>VerboseResult&lt;EstimationProbe&gt;</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="example-of-verbose-api-usage"><a class="anchor" href="#example-of-verbose-api-usage"></a>5.2.3. Example of Verbose API usage</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">VerboseResult&lt;ConsumptionProbe&gt; verboseResult = bucket.asVerbose().tryConsumeAndReturnRemaining(numberOfTokens);

BucketConfiguration bucketConfiguration = verboseResult.getConfiguration();
long capacity = Arrays.stream(bucketConfiguration.getBandwidths())
                .mapToLong(Bandwidth::getCapacity)
                .max().getAsLong();
response.addHeader("RateLimit-Limit", "" + capacity));

VerboseResult.Diagnostics diagnostics = result.getDiagnostics()
response.addHeader("RateLimit-Remaining", "" + diagnostics.getAvailableTokens());
response.addHeader("RateLimit-Reset", "" + TimeUnit.NANOSECONDS.toSeconds(diagnostics.calculateFullRefillingTime()));

ConsumptionProbe probe = verboseResult.getValue();
if (probe.isConsumed()) {
    // the limit is not exceeded
    filterChain.doFilter(servletRequest, servletResponse);
} else {
    // limit is exceeded
    HttpServletResponse httpResponse = (HttpServletResponse) servletResponse;
    httpResponse.setStatus(429);
    httpResponse.setContentType("text/plain");
    httpResponse.getWriter().append("Too many requests");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuration-replacement"><a class="anchor" href="#configuration-replacement"></a>5.3. On-the-fly configuration replacement</h3>
<div class="paragraph">
<p>As previously mentioned in the definition for <a href="#bucket-bonfiguration">BucketConfiguration</a> it is immutable object.
It is not possible to add, remove or change the limits for already created configuration, however, you can replace configuration of bucket via creating new configuration instance and calling <code>bucket.replaceConfiguration(newConfiguration, tokensInheritanceStrategy)</code>.</p>
</div>
<div class="sect3">
<h4 id="why-configuration-replacement-is-not-trivial"><a class="anchor" href="#why-configuration-replacement-is-not-trivial"></a>5.3.1. Why configuration replacement is not trivial?</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The first problem of configuration replacement is making decision how to propagate available tokens from bucket with previous configuration to bucket with new configuration. If you don&#8217;t care about previous bucket state then use <code>TokensInheritanceStrategy.RESET</code>. But it becomes to a tricky problem when we expect that previous consumption(that has not been compensated by refill yet) should take effect to the bucket with new configuration. In this case you need to make a choice between:</p>
<div class="ulist">
<ul>
<li>
<p><a href="#tokens-inheritance-strategy-proportionally">TokensInheritanceStrategy.PROPORTIONALLY</a></p>
</li>
<li>
<p><a href="#tokens-inheritance-strategy-as-is">TokensInheritanceStrategy.AS_IS</a></p>
</li>
<li>
<p><a href="#tokens-inheritance-strategy-additive">TokensInheritanceStrategy.ADDITIVE</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>There is another problem when you are choosing <a href="#tokens-inheritance-strategy-proportionally">PROPORTIONALLY</a>, <a href="#tokens-inheritance-strategy-as-is">AS_IS</a> or <a href="#tokens-inheritance-strategy-additive">ADDITIVE</a> or <a href="#tokens-inheritance-strategy-as-is">AS_IS</a>  and bucket has more then one bandwidth. For example how does replaceConfiguration implementation should bind bandwidths to each other in the following example?</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre>Bucket bucket = Bucket4j.builder()
    .addLimit(Bandwidth.simple(10, Duration.ofSeconds(1)))
    .addLimit(Bandwidth.simple(10000, Duration.ofHours(1)))
    .build();
    ...
BucketConfiguration newConfiguration = Bucket4j.configurationBuilder()
    .addLimit(Bandwidth.simple(5000, Duration.ofHours(1)))
    .addLimit(Bandwidth.simple(100, Duration.ofSeconds(10)))
    .build();
bucket.replaceConfiguration(newConfiguration, TokensInheritanceStrategy.AS_IS);</pre>
</div>
</div>
<div class="paragraph">
<p>It is obviously that simple strategy - copying tokens by bandwidth index will not work well in this case, because of it highly depends on order in which bandwidths were mentioneed in new and previous configuration.</p>
</div>
</div>
<div class="sect3">
<h4 id="taking-control-over-replacement-process-via-bandwidth-identifiers"><a class="anchor" href="#taking-control-over-replacement-process-via-bandwidth-identifiers"></a>5.3.2. Taking control over replacement process via bandwidth identifiers</h4>
<div class="paragraph">
<p>Instead of inventing the backward maggic Bucket4j provides to you ability to deap controll of this process by specifying identifiers for bandwidth,
so in case of multiple bandwidth configuratoin replacement code can copy available tokens by bandwidth ID. So it is better to rewrite code above as following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Bucket bucket = Bucket4j.builder()
     .addLimit(Bandwidth.simple(10, Duration.ofSeconds(1)).withId("technical-limit"))
     .addLimit(Bandwidth.simple(10000, Duration.ofHours(1)).withId("business-limit"))
     .build();
     ...
     BucketConfiguration newConfiguration = Bucket4j.configurationBuilder()
        .addLimit(Bandwidth.simple(5000, Duration.ofHours(1)).withId("business-limit"))
        .addLimit(Bandwidth.simple(100, Duration.ofSeconds(10)).withId("technical-limit"))
        .build();
     bucket.replaceConfiguration(newConfiguration, TokensInheritanceStrategy.PROPORTIONALLY);</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">There are following rules for bandwidth identifiers:</div>
<ul>
<li>
<p>By default bandwidth has &lt;b&gt;null&lt;/b&gt; identifier.</p>
</li>
<li>
<p>null value of identifier equals to another null value if and only if there is only one bandwidth with null identifier.</p>
</li>
<li>
<p>If identifier for bandwidth is specified then it must has unique in the bucket. Bucket does not allow to create several bandwidth with same ID.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="tokensinheritancestrategy-explanation"><a class="anchor" href="#tokensinheritancestrategy-explanation"></a>5.3.3. TokensInheritanceStrategy explanation</h4>
<div class="paragraph">
<p><strong>TokensInheritanceStrategy</strong> specifies the rules for inheritance of available tokens during configuration replacement process.</p>
</div>
<div class="dlist">
<div class="title">There are four strategies:</div>
<dl>
<dt class="hdlist1">PROPORTIONALLY</dt>
<dd>
<p>Makes to copy available tokens proportional to bandwidth capacity by following formula: <strong>newAvailableTokens = availableTokensBeforeReplacement * (newBandwidthCapacity / capacityBeforeReplacement)</strong></p>
<div class="ulist">
<div class="title">PROPORTIONALLY strategy examples:</div>
<ul>
<li>
<p><strong>Example 1:</strong> imagine bandwidth that was created by <code>Bandwidth.classic(100, Refill.gready(10, Duration.ofMinutes(1)))</code>.<br></p>
<div class="paragraph">
<p>At the moment of config replacement it was 40 available tokens.<br></p>
</div>
<div class="paragraph">
<p>After replacing this bandwidth by following <code>Bandwidth.classic(200, Refill.gready(10, Duration.ofMinutes(1)))</code> 40 available tokens will be multiplied by 2(200/100), and after replacement we will have 80 available tokens.</p>
</div>
</li>
<li>
<p><strong>Example 2:</strong> imagine bandwidth that was created by <code>Bandwidth.classic(100, Refill.gready(10, Duration.ofMinutes(1)))</code>.
At the moment of config replacement it was 40 available tokens. After replacing this bandwidth by following <code>Bandwidth.classic(20, Refill.gready(10, Duration.ofMinutes(1)))</code> 40 available tokens will be multiplied by 0.2(20/100), and after replacement we will have 8 available tokens.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">AS_IS</dt>
<dd>
<p>Instructs to copy available tokens as is, but with one exclusion: if available tokens is greater than new capacity, available tokens will be decreased to new capacity.</p>
<div class="ulist">
<div class="title">AS_IS strategy examples:</div>
<ul>
<li>
<p><strong>Example 1:</strong> imagine bandwidth that was created by <code>Bandwidth.classic(100, Refill.gready(10, Duration.ofMinutes(1)))</code>.<br></p>
<div class="paragraph">
<p>At the moment of config replacement it was 40 available tokens.<br></p>
</div>
<div class="paragraph">
<p>After replacing this bandwidth by following <code>Bandwidth.classic(200, Refill.gready(10, Duration.ofMinutes(1)))}</code> 40 available tokens will be just copied, and after replacement we will have 40 available tokens.</p>
</div>
</li>
<li>
<p><strong>Example 2:</strong> imagine bandwidth that was created by <code>Bandwidth.classic(100, Refill.gready(10, Duration.ofMinutes(1)))</code>.<br></p>
<div class="paragraph">
<p>At the moment of config replacement it was 40 available tokens.<br></p>
</div>
<div class="paragraph">
<p>After replacing this bandwidth by following <code>Bandwidth.classic(20, Refill.gready(10, Duration.ofMinutes(1)))</code> 40 available tokens can not be copied as is, because it is greater than new capacity, so available tokens will be reduced to 20.</p>
</div>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">RESET</dt>
<dd>
<p>Use this mode when you want just to forget about previous bucket state. RESET just instructs to erases all previous state. Using this strategy equals to removing bucket and creating again with new configuration.</p>
</dd>
<dt class="hdlist1">ADDITIVE</dt>
<dd>
<p>Instructs to copy available tokens as is, but with one exclusion: if new bandwidth capacity is greater than old capacity, available tokens will be increased by the difference between the old and the new configuration.<br></p>
<div class="paragraph">
<p><strong>The formula is following:</strong><br>
<code>newAvailableTokens = Math.min(availableTokensBeforeReplacement, newBandwidthCapacity) + Math.max(0, newBandwidthCapacity - capacityBeforeReplacement)</code><br></p>
</div>
<div class="ulist">
<div class="title">ADDITIVE strategy examples:</div>
<ul>
<li>
<p><strong>Example 1:</strong> imagine bandwidth that was created by <code>Bandwidth.classic(100, Refill.gready(10, Duration.ofMinutes(1)))</code>.<br></p>
<div class="paragraph">
<p>At the moment of configuration replacement, it was 40 available tokens.<br></p>
</div>
<div class="paragraph">
<p>After replacing this bandwidth by following <code>Bandwidth.classic(200, Refill.gready(10, Duration.ofMinutes(1)))</code> 40 available tokens will be copied and added to the difference between old and new configuration, and after replacement, we will have 140 available tokens.</p>
</div>
</li>
<li>
<p><strong>Example 2:</strong> imagine bandwidth that was created by <code>Bandwidth.classic(100, Refill.gready(10, Duration.ofMinutes(1)))</code>.<br></p>
<div class="paragraph">
<p>At the moment of config replacement it was 40 available tokens.<br></p>
</div>
<div class="paragraph">
<p>After replacing this bandwidth by following <code>Bandwidth.classic(20, Refill.gready(10, Duration.ofMinutes(1))))</code>,
and after replacement we will have 20 available tokens.</p>
</div>
</li>
<li>
<p><strong>Example 3:</strong> imagine bandwidth that was created by <code>Bandwidth.classic(100, Refill.gready(10, Duration.ofMinutes(1)))</code>.<br></p>
<div class="paragraph">
<p>At the moment of config replacement it was 10 available tokens.</p>
</div>
<div class="paragraph">
<p>After replacing this bandwidth by following <code>Bandwidth.classic(20, Refill.gready(10, Duration.ofMinutes(1))))</code>, and after replacement we will have 10 available tokens.</p>
</div>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 7.0.0<br>
Last updated 2021-11-26 12:01:13 +0300
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>